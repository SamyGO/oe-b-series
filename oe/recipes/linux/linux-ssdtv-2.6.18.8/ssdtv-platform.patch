# This patch content was copied from Samsung kernel sources SELP.3.2.x-Chelsea.src.tgz,
# from package released as GPL v2 http://www.samsung.com/global/opensource/files/32B650.zip
# and http://opensource.samsung.com -> UE40C8000.zip -> linux.tgz
diff -urNP old/arch/arm/Kconfig new/arch/arm/Kconfig
--- old/arch/arm/Kconfig	2010-07-17 13:15:19.000000000 +0200
+++ new/arch/arm/Kconfig	2010-07-17 13:21:19.000000000 +0200
@@ -119,7 +119,10 @@
 
 choice
 	prompt "ARM system type"
-	default ARCH_VERSATILE
+	default ARCH_SSDTV
+
+config ARCH_SSDTV
+	bool "Samsung DTV"
 
 config ARCH_AAEC2000
 	bool "Agilent AAEC-2000 based"
@@ -317,6 +320,8 @@
 
 endchoice
 
+source "arch/arm/mach-ssdtv/Kconfig"
+
 source "arch/arm/mach-clps711x/Kconfig"
 
 source "arch/arm/mach-ep93xx/Kconfig"
@@ -410,7 +415,7 @@
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_SSDTV
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
diff -urNP old/arch/arm/Makefile new/arch/arm/Makefile
--- old/arch/arm/Makefile	2007-02-24 00:52:30.000000000 +0100
+++ new/arch/arm/Makefile	2010-07-17 13:21:19.000000000 +0200
@@ -16,9 +16,7 @@
 GZFLAGS		:=-9
 #CFLAGS		+=-pipe
 
-# Do not use arch/arm/defconfig - it's always outdated.
-# Select a platform tht is kept up-to-date
-KBUILD_DEFCONFIG := versatile_defconfig
+CFLAGS>		+=$(call cc-option,-marm,)
 
 # defines filename extension depending memory manement type.
 ifeq ($(CONFIG_MMU),)
@@ -64,10 +62,10 @@
 tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
 tune-$(CONFIG_CPU_XSCALE)	:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
 tune-$(CONFIG_CPU_XSC3)		:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
-tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
+tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=arm1136jfs)
 
 ifeq ($(CONFIG_AEABI),y)
-CFLAGS_ABI	:=-mabi=aapcs-linux -mno-thumb-interwork
+CFLAGS_ABI	:=$(call cc-option,-mabi=aapcs-linux,-mabi=aapcs) -mno-thumb-interwork
 else
 CFLAGS_ABI	:=$(call cc-option,-mapcs-32,-mabi=apcs-gnu) $(call cc-option,-mno-thumb-interwork,)
 endif
@@ -119,6 +117,7 @@
  machine-$(CONFIG_ARCH_EP93XX)     := ep93xx
  machine-$(CONFIG_ARCH_PNX4008)    := pnx4008
  machine-$(CONFIG_ARCH_NETX)       := netx
+ machine-$(CONFIG_ARCH_SSDTV)      := ssdtv
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
@@ -197,7 +196,7 @@
 # Convert bzImage to zImage
 bzImage: zImage
 
-zImage Image xipImage bootpImage uImage: vmlinux
+zImage Image xipImage bootpImage uImage uzImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
 
 zinstall install: vmlinux
diff -urNP old/arch/arm/boot/Makefile new/arch/arm/boot/Makefile
--- old/arch/arm/boot/Makefile	2007-02-24 00:52:30.000000000 +0100
+++ new/arch/arm/boot/Makefile	2010-07-17 13:21:19.000000000 +0200
@@ -27,7 +27,7 @@
 
 export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
-targets := Image zImage xipImage bootpImage uImage
+targets := Image zImage xipImage bootpImage uImage uzImage
 
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
@@ -64,9 +64,13 @@
 		   -C none -a $(ZRELADDR) -e $(ZRELADDR) \
 		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
 
-$(obj)/uImage:	$(obj)/zImage FORCE
+$(obj)/uImage:	$(obj)/Image FORCE
 	$(call if_changed,uimage)
-	@echo '  Image $@ is ready'
+	@echo '  uImage $@ is ready'
+
+$(obj)/uzImage:	$(obj)/zImage FORCE
+	$(call if_changed,uimage)
+	@echo '  zImage $@ is ready'
 
 $(obj)/bootp/bootp: $(obj)/zImage initrd FORCE
 	$(Q)$(MAKE) $(build)=$(obj)/bootp $@
diff -urNP old/arch/arm/kernel/armksyms.c new/arch/arm/kernel/armksyms.c
--- old/arch/arm/kernel/armksyms.c	2010-07-17 13:16:08.000000000 +0200
+++ new/arch/arm/kernel/armksyms.c	2010-07-17 13:21:19.000000000 +0200
@@ -182,3 +182,8 @@
 	/* syscalls */
 EXPORT_SYMBOL(sys_exit);
 EXPORT_SYMBOL(sys_wait4);
+
+#if defined(CONFIG_ARCH_SSDTV)
+EXPORT_SYMBOL(sys_mknod);
+EXPORT_SYMBOL(sys_unlink);
+#endif
diff -urNP old/arch/arm/kernel/head.S new/arch/arm/kernel/head.S
--- old/arch/arm/kernel/head.S	2010-07-17 13:15:19.000000000 +0200
+++ new/arch/arm/kernel/head.S	2010-08-31 22:01:05.000000000 +0200
@@ -72,6 +72,9 @@
 ENTRY(stext)
 	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
 						@ and irqs disabled
+#if defined(CONFIG_MACH_SSDTV)
+	ldr	r1, =10001			@ SamyGO: set machine for B series
+#endif
 	mrc	p15, 0, r9, c0, c0		@ get processor id
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
diff -urNP old/arch/arm/mach-ssdtv/Kconfig new/arch/arm/mach-ssdtv/Kconfig
--- old/arch/arm/mach-ssdtv/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/Kconfig	2010-08-29 18:39:25.000000000 +0200
@@ -0,0 +1,36 @@
+if ARCH_SSDTV
+
+menu "Samsung DTV"
+
+choice
+	prompt "Samsung DTV"
+	default MACH_SSDTV
+
+config MACH_SSDTV
+	depends ARCH_SSDTV
+	bool "Samsung DTV Platform"
+	select ARM_AMBA
+	select ARCH_DISCONTIGMEM_ENABLE
+	select PCI
+	select CPU_V6
+	select VFP
+
+endchoice
+
+config SSDTV_PCI
+	default y
+	depends on PCI
+	bool "SSDTV PCI bus driver"
+
+config SSDTV_256MB
+	default n
+	bool "Set memory layout to 2x128MB"
+
+# WFI Command Not use
+config NOT_USE_WFI
+        bool "Not use WFI command"
+# WFI Command Not use End
+
+endmenu
+
+endif
diff -urNP old/arch/arm/mach-ssdtv/Makefile new/arch/arm/mach-ssdtv/Makefile
--- old/arch/arm/mach-ssdtv/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/Makefile	2010-07-18 12:45:13.000000000 +0200
@@ -0,0 +1 @@
+obj-y := ssdtv.o mach-ssdtv.o ssdtv_clock.o ssdtv_irq.o ssdtv_timer.o ssdtv_i2c.o pci.o ssdtv_pci.o ssdtv_gpio.o ssdtv_gpio_ports.o
diff -urNP old/arch/arm/mach-ssdtv/Makefile.boot new/arch/arm/mach-ssdtv/Makefile.boot
--- old/arch/arm/mach-ssdtv/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/Makefile.boot	2010-07-17 13:21:19.000000000 +0200
@@ -0,0 +1,5 @@
+ifeq ($(CONFIG_MACH_SSDTV),y)
+zreladdr-y      := 0x60008000
+params_phys-y   := 0x60000100
+initrd_phys-y   := 0x60800000
+endif
diff -urNP old/arch/arm/mach-ssdtv/mach-ssdtv.c new/arch/arm/mach-ssdtv/mach-ssdtv.c
--- old/arch/arm/mach-ssdtv/mach-ssdtv.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/mach-ssdtv.c	2010-08-31 20:45:31.000000000 +0200
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2008 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com  06/19/2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/arch/arm/mach-ssdtv/
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/map.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach/arch.h>
+
+extern void ssdtv_init_irq(void); 
+extern struct sys_timer ssdtv_timer; 
+extern void ssdtv_init(void);
+extern void ssdtv_iomap_init(void);
+
+static struct map_desc machine_io_desc[] __initdata = {
+{	/* DTV sub block A */
+	.virtual = 0xE0000000,
+	.pfn     = __phys_to_pfn(MACH_MEM0_BASE + SYS_MEM0_SIZE),
+	.length  = MACH_MEM0_SIZE - SYS_MEM0_SIZE,
+	.type    = MT_DEVICE 
+},
+
+{	/* DTV sub block B */
+	.virtual = 0xE6000000,
+	.pfn     = __phys_to_pfn(MACH_MEM1_BASE + SYS_MEM1_SIZE),
+	.length  = MACH_MEM1_SIZE - SYS_MEM1_SIZE,
+	.type    = MT_DEVICE 
+},
+
+{	/* PCI configuration */
+	.virtual = 0xF0000000,
+	.pfn     = __phys_to_pfn(0x50000000),
+	.length  = SZ_64M,
+	.type    = MT_DEVICE 
+},
+
+{	/* PCI I/O */
+	.virtual = 0xF4000000,
+	.pfn     = __phys_to_pfn(0x5C000000),
+	.length  = SZ_32M,
+	.type    = MT_DEVICE 
+},
+};
+
+static void __init machine_iomap_init(void)
+{
+	iotable_init(machine_io_desc, ARRAY_SIZE(machine_io_desc));
+}
+
+static void __init machine_map_io(void)
+{
+	// initialize iomap of special function register address
+	ssdtv_iomap_init();
+
+	// initialize iomap for peripheral device
+	machine_iomap_init();
+}
+
+static void __init machine_init(void)
+{
+	ssdtv_init();
+
+	// Set USB Register
+	*(volatile unsigned int *)(VA_EHCI0_BASE + 0x94) = 0x00780020;
+	*(volatile unsigned int *)(VA_EHCI0_BASE + 0x9C) = 0x00000000;
+
+	*(volatile unsigned int *)(VA_EHCI1_BASE + 0x94) = 0x00780020;
+	*(volatile unsigned int *)(VA_EHCI1_BASE + 0x9C) = 0x00000000;
+}
+
+static void __init machine_fixup(struct machine_desc *mdesc, struct tag *tags, char **cmdline, struct meminfo *meminfo)
+{
+	meminfo->nr_banks = 2;
+
+	meminfo->bank[0].start = MACH_MEM0_BASE;
+	meminfo->bank[0].size =  SYS_MEM0_SIZE;
+	meminfo->bank[0].node =  0;
+
+	meminfo->bank[1].start = MACH_MEM1_BASE;
+	meminfo->bank[1].size =  SYS_MEM1_SIZE;
+	meminfo->bank[1].node =  1;
+}
+
+MACHINE_START(SSDTV, "Samsung DTV (Chelsea) B series")
+	.phys_io	= PA_IO_BASE0,
+	.io_pg_offst	= VA_IO_BASE0,
+	.boot_params	= (PHYS_OFFSET + 0x100),
+	.map_io		= machine_map_io,
+	.init_irq	= ssdtv_init_irq,
+	.timer		= &ssdtv_timer,
+	.init_machine	= machine_init,
+	.fixup		= machine_fixup,
+MACHINE_END
+
diff -urNP old/arch/arm/mach-ssdtv/pci.c new/arch/arm/mach-ssdtv/pci.c
--- old/arch/arm/mach-ssdtv/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/pci.c	2010-08-31 20:47:52.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2007 Samsung electronics.co
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/arch/arm/mach-ssdtv/
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/mach/pci.h>
+#include <asm/mach-types.h>
+
+static inline int bridge_swizzle(int pin, unsigned int slot) 
+{
+	return (pin + slot) & 3;
+}
+
+/*
+ * This routine handles multiple bridges.
+ */
+u8 __init ssdtv_pci_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	int pin = *pinp;
+
+	if (pin == 0)
+		pin = 1;
+
+	pin -= 1;
+	while (dev->bus->self) {
+		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		/*
+		 * move up the chain of bridges, swizzling as we go.
+		 */
+		dev = dev->bus->self;
+	}
+	*pinp = pin + 1;
+
+	return PCI_SLOT(dev->devfn);
+}
+
+extern void pci_ssdtv_pre_init(void);
+extern void pci_ssdtv_post_init(void);
+
+extern int ssdtv_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+extern int ssdtv_pci_setup(int nr, struct pci_sys_data *sys);
+extern struct pci_bus *ssdtv_pci_scan_bus(int nr, struct pci_sys_data *sys);
+
+static struct hw_pci ssdtv_pci __initdata = {
+	.swizzle		= ssdtv_pci_swizzle,
+	.map_irq		= ssdtv_pci_map_irq,
+	.setup			= ssdtv_pci_setup,
+	.nr_controllers		= 1,
+	.scan			= ssdtv_pci_scan_bus,
+	.preinit		= pci_ssdtv_pre_init,
+	.postinit		= pci_ssdtv_post_init,
+};
+
+extern void pci_common_init(struct hw_pci *hw);
+
+static int __init ssdtv_pci_init(void)
+{
+#ifdef CONFIG_SSDTV_PCI
+	pci_common_init(&ssdtv_pci);
+#endif
+	return 0;
+}
+
+subsys_initcall(ssdtv_pci_init);
diff -urNP old/arch/arm/mach-ssdtv/ssdtv.c new/arch/arm/mach-ssdtv/ssdtv.c
--- old/arch/arm/mach-ssdtv/ssdtv.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv.c	2010-09-01 04:39:20.000000000 +0200
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2008 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com	06/19/2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/arch/arm/mach-ssdtv/
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/arch/ssdtv.h>
+
+static struct map_desc ssdtv_io_desc[] __initdata = {
+/* ------------------------------------------- */
+/* ------ special function register ---------- */
+/* ------------------------------------------- */
+// 0x3000_0000 ~ 0x3000_FFFF, 64KByte
+ { 
+	.virtual = 0xf8000000,
+	.pfn     = __phys_to_pfn(0x30000000),
+	.length  = SZ_8M + SZ_4M,
+	.type    = MT_DEVICE 
+ },
+// 0x3001_0000 ~ 0x3001_FFFF, 64KByte Don't access this region
+};
+
+static struct resource ssdtv_uart0_resource[] = {
+	[0] = {
+		.start 	= PA_UART_BASE,
+		.end	= PA_UART_BASE + 0x30,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IRQ_UART0,
+		.end	= IRQ_UART0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ssdtv_uart1_resource[] = {
+	[0] = {
+		.start 	= PA_UART_BASE + 0x40,
+		.end	= PA_UART_BASE + 0x40 + 0x30,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IRQ_UART1,
+		.end	= IRQ_UART1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ssdtv_uart2_resource[] = {
+	[0] = {
+		.start 	= PA_UART_BASE + 0x80,
+		.end	= PA_UART_BASE + 0x80 + 0x30,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IRQ_UART2,
+		.end	= IRQ_UART2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/* EHCI host controller */
+static struct resource ssdtv_ehci0_resource[] = {
+	[0] = {
+		.start  = PA_EHCI0_BASE,
+		.end    = PA_EHCI0_BASE + 0x100,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB_EHCI0,
+		.end    = IRQ_USB_EHCI0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ssdtv_ehci1_resource[] = {
+	[0] = {
+		.start  = PA_EHCI1_BASE,
+		.end    = PA_EHCI1_BASE + 0x100,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB_EHCI1,
+		.end    = IRQ_USB_EHCI1,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+/* USB 2.0 companion OHCI */
+static struct resource ssdtv_ohci0_resource[] = {
+	[0] = {
+		.start  = PA_OHCI0_BASE,
+		.end    = PA_OHCI0_BASE + 0x100,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB_OHCI0,
+		.end    = IRQ_USB_OHCI0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ssdtv_ohci1_resource[] = {
+	[0] = {
+		.start  = PA_OHCI1_BASE,
+		.end    = PA_OHCI1_BASE + 0x100,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB_OHCI1,
+		.end    = IRQ_USB_OHCI1,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static u64 ssdtv_ehci0_dmamask = (u32)0xFFFFFFFFUL;
+static u64 ssdtv_ehci1_dmamask = (u32)0xFFFFFFFFUL;
+static u64 ssdtv_ohci0_dmamask = (u32)0xFFFFFFFFUL;
+static u64 ssdtv_ohci1_dmamask = (u32)0xFFFFFFFFUL;
+
+static struct platform_device ssdtv_uart0 = {
+	.name		= "ssdtv-uart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(ssdtv_uart0_resource),
+	.resource	= ssdtv_uart0_resource,
+};
+
+static struct platform_device ssdtv_uart1 = {
+	.name		= "ssdtv-uart",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(ssdtv_uart1_resource),
+	.resource	= ssdtv_uart1_resource,
+};
+
+static struct platform_device ssdtv_uart2 = {
+	.name		= "ssdtv-uart",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(ssdtv_uart2_resource),
+	.resource	= ssdtv_uart2_resource,
+};
+
+/* USB Host controllers */
+static struct platform_device ssdtv_ehci0 = {
+	.name           = "ehci-ssdtv",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &ssdtv_ehci0_dmamask,
+		.coherent_dma_mask      = 0xFFFFFFFFUL,
+	},
+	.num_resources  = ARRAY_SIZE(ssdtv_ehci0_resource),
+	.resource       = ssdtv_ehci0_resource,
+};
+
+static struct platform_device ssdtv_ehci1 = {
+	.name           = "ehci-ssdtv",
+	.id             = 1,
+	.dev = {
+		.dma_mask               = &ssdtv_ehci1_dmamask,
+		.coherent_dma_mask      = 0xFFFFFFFFUL,
+	},
+	.num_resources  = ARRAY_SIZE(ssdtv_ehci1_resource),
+	.resource       = ssdtv_ehci1_resource,
+};
+
+static struct platform_device ssdtv_ohci0 = {
+	.name           = "ohci-ssdtv",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &ssdtv_ohci0_dmamask,
+		.coherent_dma_mask      = 0xFFFFFFFFUL,
+	},
+	.num_resources  = ARRAY_SIZE(ssdtv_ohci0_resource),
+	.resource       = ssdtv_ohci0_resource,
+};
+
+static struct platform_device ssdtv_ohci1 = {
+	.name           = "ohci-ssdtv",
+	.id             = 1,
+	.dev = {
+		.dma_mask               = &ssdtv_ohci1_dmamask,
+		.coherent_dma_mask      = 0xFFFFFFFFUL,
+	},
+	.num_resources  = ARRAY_SIZE(ssdtv_ohci1_resource),
+	.resource       = ssdtv_ohci1_resource,
+};
+
+static struct platform_device *ssdtv_init_devs[] __initdata = {
+	&ssdtv_uart0,
+	&ssdtv_uart1,
+	&ssdtv_uart2,
+	&ssdtv_ehci0,
+	&ssdtv_ohci0,
+	&ssdtv_ehci1,
+	&ssdtv_ohci1,
+};
+
+void __init ssdtv_iomap_init(void)
+{
+	iotable_init(ssdtv_io_desc, ARRAY_SIZE(ssdtv_io_desc));
+}
+
+void __init ssdtv_gpio_init(void);
+
+void __init ssdtv_init(void)
+{
+	ssdtv_gpio_init();
+	platform_add_devices(ssdtv_init_devs, ARRAY_SIZE(ssdtv_init_devs));
+}
+
+EXPORT_SYMBOL(ssdtv_iomap_init);
+EXPORT_SYMBOL(ssdtv_init);
+
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_clock.c new/arch/arm/mach-ssdtv/ssdtv_clock.c
--- old/arch/arm/mach-ssdtv/ssdtv_clock.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_clock.c	2010-07-18 12:21:21.000000000 +0200
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2008 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com 	06/19/2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/mach-sdp/sdp_clock.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+
+#include <asm/semaphore.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/platform.h>
+
+struct module;
+
+struct clk {
+	struct list_head	list;
+	struct module		*owner;
+	struct clk		*source;
+	const char		*name;
+
+	atomic_t		used;
+	unsigned long		rate;
+	int			ctrlbit;
+};
+
+
+static LIST_HEAD(clocks);
+static DECLARE_MUTEX(clocks_sem);
+
+static void ssdtv_init_clock(void);
+
+static struct clk fclk = {
+	.source = NULL,
+	.name	= "FCLK",
+	.rate	= 0,
+	.ctrlbit = -1,
+};
+
+static struct clk dclk = {
+	.source = NULL,
+	.name	= "DCLK",
+	.rate	= 0,
+	.ctrlbit = -1,
+};
+
+static struct clk hclk = {
+	.source = NULL,
+	.name	= "HCLK",
+	.rate	= 0,
+	.ctrlbit = -1,
+};
+
+static struct clk pclk = {
+	.source = NULL,
+	.name	= "PCLK",
+	.rate	= 0,
+	.ctrlbit = -1,
+};
+
+static struct clk init_clocks[] = {};
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *pclk = ERR_PTR(-ENOENT);
+
+	down(&clocks_sem);
+	list_for_each_entry(p, &clocks, list) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			pclk = p;
+			break;
+		}
+	}
+	up(&clocks_sem);
+
+	return pclk;
+}
+
+void clk_put(struct clk *clk)
+{
+	module_put(clk->owner); 
+}
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+
+void clk_disable(struct clk *clk) { }
+
+int clk_use(struct clk *clk)
+{
+	atomic_inc(&clk->used);
+	return 0;
+}
+
+void clk_unuse(struct clk *clk)
+{
+	if (clk->used.counter > 0)
+		atomic_dec(&clk->used); 
+}
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return (clk->rate) ? clk->rate : clk->source->rate;
+}
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return rate;
+}
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	printk(KERN_WARNING "Can't support to chagne rate\n");
+	return 0;
+}
+
+int clk_register(struct clk* clk)
+{
+	clk->owner = THIS_MODULE;
+	atomic_set(&clk->used, 0);
+
+	down(&clocks_sem);
+	list_add(&clk->list, &clocks);
+	up(&clocks_sem);
+
+	return 0;
+}
+
+
+unsigned long ssdtv_get_clock(char mode)
+{
+	if (!fclk.rate)
+		ssdtv_init_clock();
+
+	switch (mode){
+		case (REQ_DCLK):
+			return dclk.rate;
+			break;
+
+		case (REQ_HCLK):
+			return hclk.rate;
+			break;
+
+#if (REQ_HCLK != REQ_PCLK)
+		case (REQ_PCLK):
+			return pclk.rate;
+			break;
+#endif
+
+		case (REQ_FCLK):
+		default:
+			return fclk.rate;
+			break;
+	}
+}
+
+static void ssdtv_init_clock(void)
+{
+	unsigned int corePll = R_PMU_PLL0_PMS_CON;
+	unsigned int ddr2Pll = R_PMU_PLL1_PMS_CON;
+	unsigned int busPll  = R_PMU_PLL2_PMS_CON;
+
+	if (fclk.rate)
+		return;
+
+	if (R_PMU_PLL_BYPASS & 1)
+		fclk.rate = INPUT_FREQ;
+	else {
+		fclk.rate = (FIN >> GET_PLL_S(corePll)) / GET_PLL_P(corePll);
+		fclk.rate = fclk.rate * GET_PLL_M(corePll);
+	}
+
+	if (R_PMU_PLL_BYPASS & 2)
+		dclk.rate = INPUT_FREQ;
+	else {
+		dclk.rate = (FIN >> GET_PLL_S(ddr2Pll)) / GET_PLL_P(ddr2Pll);
+		dclk.rate = dclk.rate * GET_PLL_M(ddr2Pll); 
+	}
+
+	if (R_PMU_PLL_BYPASS & 4) {
+		hclk.rate = INPUT_FREQ;
+		pclk.rate = hclk.rate;
+	} else {
+		hclk.rate = (FIN >> GET_PLL_S(busPll)) / GET_PLL_P(busPll);
+		hclk.rate = hclk.rate * GET_PLL_M(busPll);
+		hclk.rate = hclk.rate >> 2;
+		pclk.rate = hclk.rate;
+	}
+}
+
+int __init clk_init(void)
+{
+	struct clk *pClk = init_clocks;
+	int ptr;
+	int ret = 0;
+
+	ssdtv_init_clock();
+
+	clk_register(&fclk);
+	clk_register(&dclk);
+	clk_register(&hclk);
+	clk_register(&pclk);
+
+	for (ptr = 0; ptr < ARRAY_SIZE(init_clocks); ptr++, pClk++)
+		clk_register(pClk);
+
+	printk(KERN_INFO "Core Clock: %d.%dMhz\n", (unsigned int)fclk.rate / MHZ, (unsigned int)fclk.rate % MHZ / 1000);
+	printk(KERN_INFO "DDR2 Clock: %d.%dMhz\n", (unsigned int)dclk.rate / MHZ, (unsigned int)dclk.rate % MHZ / 1000);
+	printk(KERN_INFO "AHB Clock: %d.%dMhz\n", (unsigned int)hclk.rate / MHZ, (unsigned int)hclk.rate % MHZ / 1000);
+	printk(KERN_INFO "APB Clock: %d.%dMhz\n", (unsigned int)pclk.rate / MHZ, (unsigned int)pclk.rate % MHZ / 1000);
+
+	return ret;
+}
+
+arch_initcall(clk_init);
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_gpio.c new/arch/arm/mach-ssdtv/ssdtv_gpio.c
--- old/arch/arm/mach-ssdtv/ssdtv_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_gpio.c	2010-07-18 12:46:54.000000000 +0200
@@ -0,0 +1,528 @@
+/* sdp_gpio.c
+ *
+ * Copyright (c) 2009 Samsung Electronics
+ *  Ikjoon Jang <ij.jang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_gpio.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ * Simple GPIO support for SSDTVXX.
+ * Do not declare platform devices for GPIO,
+ * Use ssdtv_gpio_add_device to register GPIO platform device.
+ */
+ 
+/* TODOs 
+ * kobj reference, sysfs interface
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/gpio_board.h>
+
+#define pdev_to_gpio(pdev)	platform_get_drvdata(pdev)
+
+#define SSDTV_GPIO_DEVNAME	"ssdtv_gpio"
+
+#define SSDTV_GPIO_DEBUG
+#define SSDTV_GPIO_DEBUG_RAW
+
+#define printerr(fmt, arg...)	\
+	do { printk(KERN_ERR "SSDTV_GPIO " fmt, ## arg); } while (0)
+
+#define printinfo(fmt, arg...)	\
+	do { printk(KERN_INFO "SSDTV_GPIO " fmt, ## arg); } while (0)
+	
+/* debug */
+#if defined(SSDTV_GPIO_DEBUG)
+#define printdbg(fmt, arg...)	\
+	do { printk(KERN_DEBUG "SSDTV_GPIO " fmt, ## arg); } while (0)
+#else
+#define printdbg(fmt, arg...)
+#endif
+
+#if defined(SSDTV_GPIO_DEBUG_RAW)
+/* debug more */
+#define printraw(fmt, arg...)	\
+	do { printk(KERN_DEBUG "SSDTV_GPIO " fmt, ## arg); } while (0)
+#else
+#define printraw(fmt, arg...)
+#endif
+
+/* driver data */
+struct ssdtv_gpio {
+	u32			reg_addr;	/* PA */
+	size_t			reg_len;	/* mapping size */	
+	int 			nports;
+
+	spinlock_t		lock_pull;	/* lock for pull registers */	
+	struct cdev		*cdev;
+
+	void __iomem		*regbase;	/* ioremapped */
+	struct ssdtv_gpio_port	ports[0];
+};
+
+static struct ssdtv_gpio *gpio_control;
+
+static inline u32 ssdtv_gpio_readl(u32 __iomem *reg)
+{
+	u32 v = readl(reg);
+	printraw("read 0x%08x = 0x%08x\n", (u32)reg, v);
+	return v;
+}
+
+static inline void ssdtv_gpio_writel(const u32 val, u32 __iomem *reg)
+{
+	printraw("write 0x%08x = 0x%08x\n", (u32)reg, val);
+	writel(val, reg);
+}
+
+static inline u32 ssdtv_gpio_writel_mask(const u32 val, u32 __iomem *reg, u32 mask, int shift)
+{
+	u32 tmp;
+
+	tmp = ssdtv_gpio_readl(reg);
+
+	tmp &= ~(mask << shift);
+	tmp |= (val & mask) << shift;
+
+	ssdtv_gpio_writel(tmp, reg);
+
+	return tmp;
+}
+
+static void lock_port(struct ssdtv_gpio_port *port)
+{
+	spin_lock(&port->lock_port);
+}
+
+static void unlock_port(struct ssdtv_gpio_port *port)
+{
+	spin_unlock(&port->lock_port);
+}
+
+static void lock_pull(struct ssdtv_gpio *gpio)
+{
+	spin_lock(&gpio->lock_pull);
+}
+
+static void unlock_pull(struct ssdtv_gpio *gpio)
+{
+	spin_unlock(&gpio->lock_pull);
+}
+static struct ssdtv_gpio_port *find_port(struct ssdtv_gpio *gpio, int port)
+{
+	int i;
+
+	for (i = 0;  i < gpio->nports; i++) {
+		if (gpio->ports[i].portno == port)
+			return &gpio->ports[i];
+	}
+	return NULL;
+}
+
+static int ssdtv_gpio_configure(struct ssdtv_gpio *gpio, struct gpio_ctl_param *param)
+{
+	struct ssdtv_gpio_port *port;
+
+	/* no control value was setted */
+	if (!(param->val & (GPIO_FUNC_MASK | GPIO_PULL_MASK)))
+		return -EINVAL;
+
+	port = find_port (gpio, param->port);
+	if (!port || param->pin >= port->npins)
+		return -ENODEV;
+
+	/* function / in / out */
+	if (param->val & GPIO_FUNC_MASK) {
+		lock_port (port);
+
+		/* TODO: check saved context */
+		switch (param->val & GPIO_FUNC_MASK) {
+		case GPIO_FUNC_IN:
+			printdbg("port%d pin%d set to input.\n", port->portno, param->pin);
+			port->control = ssdtv_gpio_writel_mask (2, &port->reg->con, 3, param->pin * 4);			
+			break;
+		case GPIO_FUNC_OUT:
+			printdbg("port%d pin%d set to output.\n", port->portno, param->pin);
+			port->control =	ssdtv_gpio_writel_mask (3, &port->reg->con, 3, param->pin * 4);			
+			break;
+		case GPIO_FUNC_FN:
+			printdbg("port%d pin%d route to main function.\n", port->portno, param->pin);
+			port->control = ssdtv_gpio_writel_mask (0, &port->reg->con, 3, param->pin * 4);
+			break;
+		default:
+			/* XXX */
+			break;
+		}
+		unlock_port(port);
+	}
+	
+	/* pull-up / pull-down */
+	if (param->val & GPIO_PULL_MASK) {
+		struct ssdtv_gpio_pull *pull;
+		u32 __iomem *pull_reg;
+		
+		if ((port->control & (3 << (param->pin * 4))) == 0) {
+			/* XXX: Can PULL UP/DN be controlled when in FUNC mode? */
+		}
+		lock_pull(gpio);
+		
+		pull = &gpio->ports[param->port].pins[param->pin];
+		pull_reg = gpio->regbase + pull->reg_offset;
+		
+		/* XXX: check saved context */
+		
+		switch (param->val & GPIO_PULL_MASK) {
+		case GPIO_PULL_OFF:
+			printdbg("port%d pin%d pull control: off.\n", port->portno, param->pin);
+			ssdtv_gpio_writel_mask(0, pull_reg, 3, pull->reg_shift);
+			pull->state = SSDTV_GPIO_PULL_OFF;
+			break;
+		case GPIO_PULL_UP:
+			printdbg("port%d pin%d pull control: up.\n", port->portno, param->pin);
+			ssdtv_gpio_writel_mask(3, pull_reg, 3, pull->reg_shift);
+			pull->state = SSDTV_GPIO_PULL_UP;
+			break;	
+		case GPIO_PULL_DN:
+			printdbg("port%d pin%d pull control: down.\n", port->portno, param->pin);
+			ssdtv_gpio_writel_mask(2, pull_reg, 3, pull->reg_shift);
+			pull->state = SSDTV_GPIO_PULL_DN;
+			break;
+		default:
+			break;
+		}
+		unlock_pull(gpio);
+	}
+	
+	return 0;
+}
+
+static void ssdtv_gpio_set(struct ssdtv_gpio_port *port, int pin, int val)
+{
+	ssdtv_gpio_writel_mask(val, &port->reg->wdat, 1, pin);
+}
+
+static int ssdtv_gpio_get(struct ssdtv_gpio_port *port, int pin)
+{
+	u32 tmp = ssdtv_gpio_readl(&port->reg->rdat);
+	if (tmp & (1<<pin))
+		return 1;
+	else
+		return 0;
+}
+
+static int ssdtv_gpio_check_rw(struct ssdtv_gpio_port *port, int pin, int write)
+{
+	u32 val = (ssdtv_gpio_readl(&port->reg->con) >> (pin * 4)) & 3;
+	
+	if (write && (val != 3)) {
+		printerr ("Write port%d pin%d: direction mismatch.\n", port->portno, pin);
+		return -EBUSY;		
+	}
+	if (!write && (val != 2)) {
+		printerr ("Read port%d pin%d: direction mismatch.\n", port->portno, pin);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int ssdtv_gpio_rw(struct ssdtv_gpio *gpio, struct gpio_ctl_param *param, int write)
+{
+	u32 val;
+	int ret;
+	struct ssdtv_gpio_port *port;
+	
+	/* no control value was setted */
+	if (param->val & (GPIO_FUNC_MASK | GPIO_PULL_MASK)) {
+		printdbg ("Control value was setted in request of io.\n");
+		return -EINVAL;
+	}
+
+	port = find_port (gpio, param->port);
+	if (!port || param->pin >= port->npins) {
+		printerr ("Invalid port or pin number.\n");
+		return -ENODEV;
+	}
+	
+	/* check direction */
+	ret = ssdtv_gpio_check_rw (port, param->pin, write);
+	if (ret) {		
+		return ret;
+	}
+	
+	lock_port (port);
+	
+	if (write) {
+		printdbg ("port%d pin%d set level to %d.\n", port->portno, param->pin, param->val);
+		val = ((param->val & GPIO_LEVEL_MASK) == GPIO_LEVEL_HIGH) ? 1 : 0;
+		ssdtv_gpio_set (port, param->pin, val);
+		ret = 0;
+	} else {
+		val = ssdtv_gpio_get (port, param->pin);
+		if (val) {
+			param->val |= GPIO_LEVEL_HIGH;
+		} else {
+			param->val &= ~(GPIO_LEVEL_MASK);
+			param->val |= GPIO_LEVEL_LOW;
+		}
+		printdbg ("port%d pin%d get level=%d.\n", port->portno, param->pin, param->val);
+		ret = 0;
+	}
+
+	unlock_port(port);
+	
+	return ret;
+}
+
+static int ssdtv_gpio_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long args)
+{
+	int ret;
+	struct gpio_ctl_param param;
+	struct ssdtv_gpio *gpio = (struct ssdtv_gpio *)filp->private_data;
+	
+	if (!gpio_control || gpio_control != gpio) {
+		printerr("Fatal.\n");
+		return -ENODEV;
+	}
+	if (copy_from_user(&param, (void *)args, sizeof(param))) {
+		printerr("Failed to get ioctl argument.\n");
+		return -EFAULT;
+	}
+	
+	switch (cmd) {
+	case GPIO_IOC_CONFIG:
+		ret = ssdtv_gpio_configure(gpio, &param);
+		break;
+	case GPIO_IOC_READ:
+		ret = ssdtv_gpio_rw(gpio, &param, 0);
+		if (ret)
+			goto exit_ioctl;
+		if (copy_to_user((void*)args, &param, sizeof(param))) {
+			printerr ("Failed to give back ioctl argument.\n");
+			ret = -EFAULT;
+		}
+		break;
+	case GPIO_IOC_WRITE:
+		ret = ssdtv_gpio_rw(gpio, &param, 1);
+		break;
+	default:
+		ret = -EINVAL;
+	};
+exit_ioctl:
+	return ret;
+}
+
+static int ssdtv_gpio_open(struct inode *inode, struct file *filp)
+{
+	if (gpio_control == NULL) {
+		return -ENODEV;
+	}
+	filp->private_data = gpio_control;
+	return 0;
+}
+
+static int ssdtv_gpio_release (struct inode *inode, struct file *filp)
+{
+	filp->private_data = NULL;
+	return 0;
+}
+
+static const struct file_operations ssdtv_gpio_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ssdtv_gpio_open,
+	.release	= ssdtv_gpio_release,
+	.ioctl		= ssdtv_gpio_ioctl,
+};
+
+int __init ssdtv_gpio_add_device(u32 addr, size_t reg_len, struct ssdtv_gpio_port *ports, int nports)
+{
+	int ret;
+	struct ssdtv_gpio *gpio = NULL;
+	struct platform_device *pdev = NULL;
+	
+	/* only 1 GPIO controller on a system */
+	if (gpio_control != NULL) {
+		return -EBUSY;
+	}
+
+	/* create internal device data */
+	gpio = kmalloc (sizeof(struct ssdtv_gpio_port) * nports + sizeof(*gpio), GFP_KERNEL);
+	if (!gpio) {
+		printerr ("Failed to allocate driver data.\n");		
+		return -ENOMEM;
+	}
+	gpio->reg_addr = addr;
+	gpio->reg_len = reg_len;
+	gpio->nports = nports;	
+	memcpy (gpio->ports, ports, sizeof(*ports) * nports);	
+	
+	/* platform device: only 1 GPIO controller on a bus */
+	pdev = platform_device_alloc (SSDTV_GPIO_DEVNAME, 0);
+	if (!pdev) {			
+		printerr ("Failed to register device.\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	
+	ret = platform_device_add (pdev);
+	if (ret) {
+		printerr ("Failed to register device to platform bus.\n");
+		goto err;
+	}
+
+	gpio_control = gpio;
+
+	printdbg ("Device is registered, %d ports.\n", nports);
+	
+	return 0;
+err:
+	if (pdev)
+		platform_device_put (pdev);
+	if (gpio)
+		kfree (gpio);
+	return ret;
+}
+
+static inline void ssdtv_gpio_port_init(void __iomem *reg, struct ssdtv_gpio_port *port)
+{
+	spin_lock_init (&port->lock_port);
+	port->reg = reg + port->reg_offset;
+	port->control = ssdtv_gpio_readl(&port->reg->con);
+}
+
+static int __devinit ssdtv_gpio_probe(struct platform_device *pdev)
+{
+	int ret, i;
+	struct cdev *cdev = NULL;
+	struct ssdtv_gpio *gpio = gpio_control;
+	struct class *class = NULL;
+	dev_t devid;
+
+	/* only 1 GPIO controller on a system */
+	if (!gpio) {
+		printerr ("No GPIO devices are defined by machine.\n");
+		return -ENODEV;
+	}
+
+	/* char device */
+	ret = alloc_chrdev_region(&devid, 0, 1, SSDTV_GPIO_DEVNAME);
+	if (ret) {
+		printerr ("Failed to alloc char device id%s.\n", SSDTV_GPIO_DEVNAME);
+		return ret;
+	}
+	cdev = cdev_alloc();
+	if (!cdev) {
+		ret = -EBUSY;
+		goto err0;
+	}
+	cdev_init(cdev, &ssdtv_gpio_fops);
+	cdev_add(cdev, devid, 1);
+	printdbg("char device registered major=%d, minor=%d.\n", MAJOR(cdev->dev), MINOR(cdev->dev));
+
+	/* class */
+	class = class_create(THIS_MODULE, SSDTV_GPIO_DEVNAME);
+	if (!class) {
+		printerr ("Failed to create sysfs gpio class.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	printdbg ("sysfs class %s is registered.\n", SSDTV_GPIO_DEVNAME);
+	
+	/* class device : fake for registering a class device */
+	/* XXX: class device is deprecated */
+	class_device_create (class, NULL, devid, &pdev->dev, "%s%d", SSDTV_GPIO_DEVNAME, 0);
+	
+	gpio->regbase = ioremap_nocache(gpio->reg_addr, gpio->reg_len);
+	if (!gpio->regbase) {
+		printerr ("Failed to map io mem.\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+	printdbg ("io mem = 0x%08x, mapped to 0x%08x.\n", gpio->reg_addr, (u32)gpio->regbase);
+	
+	spin_lock_init(&gpio->lock_pull);
+	for (i = 0; i < gpio->nports; i++) {
+		ssdtv_gpio_port_init(gpio->regbase, &gpio->ports[i]);
+	}
+	
+	platform_set_drvdata(pdev, gpio);
+	gpio->cdev = cdev;
+	
+	printinfo("Probing completed. %d ports detected.\n", gpio->nports);
+	return 0;
+err2:
+	iounmap(gpio->regbase);
+err1:
+	if (class)
+		class_destroy(class);
+	if (cdev)
+		cdev_del(cdev);	
+err0:
+	unregister_chrdev_region(devid, 1);
+	return ret;
+}
+
+/* this may not be called */
+static int __devexit ssdtv_gpio_remove (struct platform_device *pdev)
+{
+	struct ssdtv_gpio *gpio = pdev_to_gpio (pdev);
+	if (gpio) {
+		iounmap (gpio->regbase);
+		gpio->regbase = NULL;
+		if (gpio->cdev) {
+			cdev_del (gpio->cdev);
+			gpio->cdev = NULL;
+		}
+	}
+	return 0;
+}
+
+static struct platform_driver ssdtv_gpio_driver = {
+	.probe		= ssdtv_gpio_probe,
+	.remove		= ssdtv_gpio_remove,
+	.driver		= {
+		.name = SSDTV_GPIO_DEVNAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init ssdtv_gpio_init(void)
+{
+	int ret;
+	
+	ret = platform_driver_register(&ssdtv_gpio_driver);
+	if (ret < 0) {
+		printerr ("Failed to register SSDTV GPIO platform driver.\n");
+		return ret;
+	} else {
+		return 0;
+	}
+}
+module_init(ssdtv_gpio_init);
+
+static void __exit ssdtv_gpio_exit(void)
+{
+	platform_driver_unregister(&ssdtv_gpio_driver);
+}
+module_exit(ssdtv_gpio_exit);
+
+MODULE_AUTHOR ("ij.jang@samsung.com");
+MODULE_LICENSE ("GPL");
+
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_gpio_ports.c new/arch/arm/mach-ssdtv/ssdtv_gpio_ports.c
--- old/arch/arm/mach-ssdtv/ssdtv_gpio_ports.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_gpio_ports.c	2010-07-18 12:53:55.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2009 Samsung Electronics
+ *  Ikjoon Jang <ij.jang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/mach-sdp/sdp83_gpio.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ */
+
+#include <linux/module.h>
+#include <asm/arch/gpio_board.h>
+
+static struct ssdtv_gpio_port ssdtv_gpio_ports[] = {
+	{
+		.portno = 0,
+		.npins = 8,
+		.reg_offset = 0x50,
+		.pins = {
+			[0] = {.reg_offset = 0x04, .reg_shift = 10},
+			[1] = {.reg_offset = 0x04, .reg_shift = 12},
+			[2] = {.reg_offset = 0x04, .reg_shift = 14},
+			[3] = {.reg_offset = 0x04, .reg_shift = 16},
+			[4] = {.reg_offset = 0x04, .reg_shift = 18},
+			[5] = {.reg_offset = 0x04, .reg_shift = 20},
+			[6] = {.reg_offset = 0x04, .reg_shift = 22},
+			[7] = {.reg_offset = 0x04, .reg_shift = 24},
+		},
+	},
+	{
+		.portno = 1,
+		.npins = 8,
+		.reg_offset = 0x5c,
+		.pins = {
+			[0] = {.reg_offset = 0x04, .reg_shift = 26},
+			[1] = {.reg_offset = 0x04, .reg_shift = 28},
+			[2] = {.reg_offset = 0x04, .reg_shift = 30},
+			[3] = {.reg_offset = 0x08, .reg_shift = 0},
+			[4] = {.reg_offset = 0x08, .reg_shift = 2},
+			[5] = {.reg_offset = 0x1c, .reg_shift = 4},
+			[6] = {.reg_offset = 0x1c, .reg_shift = 6},
+			[7] = {.reg_offset = 0x1c, .reg_shift = 8},
+		},
+	},
+	{
+		.portno = 2,
+		.npins = 1,
+		.reg_offset = 0x64,
+		.pins = {
+			[0] = {.reg_offset = 0x1c, .reg_shift = 10},
+		},
+	},
+	{
+		.portno = 4,
+		.npins = 8,
+		.reg_offset = 0x80,
+		.pins = {
+			[0] = {.reg_offset = 0x00, .reg_shift = 24},
+			[1] = {.reg_offset = 0x00, .reg_shift = 26},
+			[2] = {.reg_offset = 0x00, .reg_shift = 28},
+			[3] = {.reg_offset = 0x00, .reg_shift = 30},
+			[4] = {.reg_offset = 0x04, .reg_shift = 0},
+			[5] = {.reg_offset = 0x04, .reg_shift = 2},
+			[6] = {.reg_offset = 0x30, .reg_shift = 20},
+			[7] = {.reg_offset = 0x30, .reg_shift = 22},
+		},
+	},
+	{
+		.portno = 5,
+		.npins = 8,
+		.reg_offset = 0x8c,
+		.pins = {
+			[0] = {.reg_offset = 0x00, .reg_shift = 20},
+			[1] = {.reg_offset = 0x00, .reg_shift = 22},
+			[2] = {.reg_offset = 0x30, .reg_shift = 24},
+			[3] = {.reg_offset = 0x30, .reg_shift = 26},
+			[4] = {.reg_offset = 0x30, .reg_shift = 28},
+			[5] = {.reg_offset = 0x30, .reg_shift = 30},
+			[6] = {.reg_offset = 0x04, .reg_shift = 6},
+			[7] = {.reg_offset = 0x04, .reg_shift = 8},
+		},
+	},
+};
+
+void __init ssdtv_gpio_init(void)
+{
+	ssdtv_gpio_add_device(PA_PADCTRL_BASE, 4096, ssdtv_gpio_ports, ARRAY_SIZE(ssdtv_gpio_ports));
+}
+
+EXPORT_SYMBOL(ssdtv_gpio_init);
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_i2c.c new/arch/arm/mach-ssdtv/ssdtv_i2c.c
--- old/arch/arm/mach-ssdtv/ssdtv_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_i2c.c	2010-09-09 06:41:01.000000000 +0200
@@ -0,0 +1,980 @@
+/*********************************************************************************************
+ *
+ *	ssdtv_i2c.c (Samsung Soc i2c device driver without i2c layer in kernel)
+ *
+ *	author : tukho.kim@samsung.com
+ *	
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/drivers/char/sdp_i2c.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ ********************************************************************************************/
+/*********************************************************************************************
+ * Description 
+ * Date 	author		Description
+ * ----------------------------------------------------------------------------------------
+// Sep,08,2008 	tukho.kim	detect i2c stop condition but i2c packet is not end
+// Dec,23,2008  tukho.kim       increase data size for one packet to 2MB
+// Dec,24,2008  tukho.kim	i2c check bus modify
+// Jan,08,2009  tukho.kim	i2c check bus modify MASTER TX -> MASTER_RX
+// Mar,04,2009  tukho.kim	-ERESTARTSYS code 
+// Mar,05,2009  tukho.kim	Timeout error 
+ ********************************************************************************************/
+
+/*
+ 1. mutex usage
+	1) init : init_MUTEX(struct semaphore *)
+	2) lock : down(struct semaphore *) - take
+	3) release : up(struct semaphore *) - give
+
+ 2. synchroniz usage
+	1) init	: init_waitqueue_head(wait_queue_head_t *q)
+	2) wait : wait_event_interruptible_timeout(wait_queue_head_t wq,int condition, int timeout) 
+	3) wakeup : wake_up_interruptible(wait_queue_head_t *wq)
+*/
+
+#define DEBUG_SSDTV_I2C
+//#define DEBUG_EXECUTE_FLOW
+
+#ifdef DEBUG_SSDTV_I2C
+#  define SSDTV_I2C_DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__, ##args)
+#else 
+#  define SSDTV_I2C_DPRINTK(fmt, args...)
+#endif
+
+#ifdef DEBUG_EXECUTE_FLOW
+#  define DPRINTK_I2C_FLOW(fmt, args...) printk("%s: " fmt, __FUNCTION__, ##args)
+#else 
+#  define DPRINTK_I2C_FLOW(fmt, args...)
+#endif
+
+#define  DRV_NAME	"ssdtv i2c"
+#define  DRV_VERSION	"0.7"
+
+#ifdef DEBUG_EXECUTE_FLOW
+#define WAIT_FACTOR	5
+#else
+#define WAIT_FACTOR	1
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/vmalloc.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include "ssdtv_i2c_io.h"
+#include "ssdtv_i2c.h"
+
+struct i2c_packet_t {
+	u8	status;			// transmission status & error status
+	u8 	slaveAddr;		// i2c slave(device) address
+	u8	subAddrSize;		// i2c sub address size
+	u8	reserve8;		// align
+	u16	udelay;			// udelay
+	u32	dataSize;		// i2c data size
+	u8	*pSubAddr;		// i2c sub address buffer
+	u8	*pData;			// i2c data buffer pointer 
+};
+
+static struct i2c_ctrl_t {
+	int 			port;		// i2c port number
+	u32 			vBase;		// i2c port vitual base
+	u8			*pDataBuffer;	// Data Buffer pointer
+	u32			useCount;
+	// synchronize resource
+	wait_queue_head_t 	syncQueue;	
+	int			syncCondition;
+	// mutex resource 	
+	struct semaphore 	mutex;
+	// packet resource
+	struct i2c_packet_t	packet;
+} i2c_ctrl[N_I2C_PORT];
+
+static u32 vPend;
+
+MODULE_AUTHOR("tukho.kim@samsung.com");
+MODULE_DESCRIPTION("Driver for SSDTV I2c rev driver without i2c layer in kernel");
+
+static void i2c_intr_stop(struct i2c_ctrl_t *pPort)
+{
+	u32 regVal;
+
+	DPRINTK_I2C_FLOW("i2c stop \n");
+	regVal = R_I2C_CON;
+	// i2c interrupt disable
+	R_I2C_CON = I2CCON_INT_DIS(regVal);
+	// stop generation 1
+	R_I2C_STAT = I2CSTAT_STOP(R_I2C_STAT & 0xF0);
+	// wake up
+	pPort->syncCondition = 1;
+	wake_up_interruptible(&pPort->syncQueue);
+	// stop generation 2
+	I2CPEND_CLEAR;
+}
+
+static void i2c_intr_write (struct i2c_ctrl_t * pPort)
+{
+	struct i2c_packet_t *pPacket = &pPort->packet;	
+
+	// check acknowledge
+	if (pPacket->reserve8 != DEBUG_ALWAYS_NOT_ACK) {
+		if (I2CSTAT_RCV_NACK(R_I2C_STAT)){
+			DPRINTK_I2C_FLOW("nack\n");
+			// set error status
+			pPacket->status |= STATUS_ERROR_FLAG;
+			i2c_intr_stop(pPort);
+			return;
+		}
+	}
+
+	// send sub address
+	if (pPacket->subAddrSize) {
+		DPRINTK_I2C_FLOW("subAddr 0x%02x\n", *pPacket->pSubAddr);
+		R_I2C_DS = *pPacket->pSubAddr;
+		pPacket->pSubAddr++;
+		I2CPEND_CLEAR;
+		pPacket->subAddrSize--;
+	}
+	// change mode to read operation for combined read command
+	else if (pPacket->status == STATUS_READ_SUBADDR) {
+		DPRINTK_I2C_FLOW("change status 0x%02x\n", pPacket->slaveAddr);
+		pPacket->status = STATUS_READ_START;
+		R_I2C_DS = pPacket->slaveAddr;
+		R_I2C_STAT = I2CSTAT_MASTER_RX;
+		I2CPEND_CLEAR;	// repeat start
+	}
+	// send data 
+	else if (pPacket->dataSize) { // data send
+		DPRINTK_I2C_FLOW("send data 0x%02x\n", *pPacket->pData);
+		R_I2C_DS = *pPacket->pData;
+		pPacket->pData++;
+		I2CPEND_CLEAR;
+		pPacket->dataSize--;
+	}
+	// stop generation
+	else { // stop 
+		DPRINTK_I2C_FLOW("stop\n");
+		i2c_intr_stop(pPort);
+	}
+}
+
+static void i2c_intr_read (struct i2c_ctrl_t * pPort)
+{
+	u32 temp;
+	struct i2c_packet_t *pPacket = &pPort->packet;	
+
+	if (pPacket->status == STATUS_READ_START) {
+		DPRINTK_I2C_FLOW("read start\n");
+		// check acknowledge
+		if (pPacket->reserve8 != DEBUG_ALWAYS_NOT_ACK) {
+			if (I2CSTAT_RCV_NACK(R_I2C_STAT)) {
+				// set error status
+				pPacket->status |= STATUS_ERROR_FLAG;
+				i2c_intr_stop(pPort);
+				return; 
+			}
+		}
+		// change mode rx
+		pPacket->status = STATUS_READ_DATA;
+		// receive 1st data
+	} else {
+		temp = R_I2C_DS & 0xFF;
+		*pPacket->pData	= (u8)temp;
+		DPRINTK_I2C_FLOW("read data 0x%02x \n", *pPacket->pData);
+		pPacket->pData++;
+		pPacket->dataSize--;
+	}
+
+	switch (pPacket->dataSize) {
+		case 0:
+			i2c_intr_stop(pPort);
+			break;
+		case 1:
+			DPRINTK_I2C_FLOW("read gen nack \n");
+			R_I2C_CON = I2CCON_GEN_NACK(R_I2C_CON);
+			I2CPEND_CLEAR;
+			break;
+		default:
+			DPRINTK_I2C_FLOW("read gen ack \n");
+			R_I2C_CON = I2CCON_GEN_ACK(R_I2C_CON);
+			I2CPEND_CLEAR;
+			break;
+	}
+}
+
+static void i2c_intr_control (struct i2c_ctrl_t * pPort)
+{
+	struct i2c_packet_t *pPacket = &pPort->packet;
+
+	// check stop generate by external environment
+	if (I2CSTAT_STOP_DETECT(R_I2C_STAT) && !(I2CSTAT_BUSY)) {
+		printk("find i2c %d stop condition detect \n", pPort->port);
+		printk("status is 0x%02x\n", pPacket->status);
+		printk("predata is 0x%02x\n", *(pPacket->pData - 1));
+
+		if (pPacket->status < STATUS_ERROR_FLAG) {
+			pPacket->status |= (STATUS_ERROR_FLAG | STATUS_STOP_DETECT);
+		}
+
+		i2c_intr_stop(pPort);	// i2c stop
+		return;
+	}
+
+	// common operation
+	switch (pPacket->status) {
+		case STATUS_WRITE:		// i2c write 
+		case STATUS_READ_SUBADDR:	// i2c comb read
+			i2c_intr_write(pPort);
+			break;
+		case STATUS_READ_START:		// i2c read
+		case STATUS_READ_DATA:		// i2c read
+			i2c_intr_read(pPort);
+			break;
+		case STATUS_TRY_READY:		// bus try to change to ready
+			i2c_intr_stop(pPort);	// i2c stop
+		default:
+			printk("i2c status is error\n");
+			pPacket->status |= STATUS_ERROR_FLAG;
+			i2c_intr_stop(pPort); // i2c stop 
+			break;
+	}
+}
+
+static irqreturn_t i2c_interrupt_handler(int irq, void *devId, struct pt_regs *regs)
+{
+	int i;
+	u32 regVal;
+	struct i2c_ctrl_t* pPort = (struct i2c_ctrl_t *) devId;
+
+	regVal = R_I2C_PEND;
+
+	for (i = 0; i < N_I2C_PORT; i++) {
+		if (regVal & (1 << i))
+			i2c_intr_control(pPort+i);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int i2c_set_clock(struct i2c_ctrl_t* pPort, u16 speedKhz)
+{
+	int retVal = 0;
+	const u32 i2cSrcClk = I2C_SRC_CLK; // unit is Khz
+	u32 khz = (u32)speedKhz;
+	u32 prescaler;
+	u32 regVal;
+
+	// Max 400Khz 
+	if (khz > 400)
+		khz = 400;
+	else if (khz < 10)
+		khz = 10;
+
+	DPRINTK_I2C_FLOW("i2c %d set clock %d Khz\n", pPort->port, speedKhz);
+
+	// choose div 16 or div16
+	regVal = R_I2C_CON;
+	regVal = I2CCON_CLK_DIV16(regVal);
+
+	prescaler = (i2cSrcClk >> 4) / khz;
+
+	if (prescaler > 63) {
+		prescaler = (i2cSrcClk >> 8) / khz;
+		regVal = I2CCON_CLK_DIV256(regVal);
+	}
+
+	R_I2C_CON = I2CCON_CLK_PRE(prescaler, regVal);
+
+	return retVal;
+}
+
+static int i2c_check_bus(struct i2c_ctrl_t *pPort)
+{
+	int retVal = 0;
+	u32 regVal;
+	int retry = 5;
+	struct i2c_packet_t *pPacket = &pPort->packet;
+
+	if (I2CSTAT_BUSY)
+		udelay(1000);	// wait to stop signal genertion 1ms 
+				// JAN,08,2009 100 ->1000 by tukho.kim
+
+	if (I2CSTAT_BUSY) {
+		regVal = I2CCON_GEN_NACK(R_I2C_CON);
+		regVal = I2CCON_INT_EN(regVal);
+		R_I2C_CON = regVal;
+
+		while (I2CSTAT_BUSY && retry) {
+			// status 
+			pPacket->status = STATUS_TRY_READY;
+			// sync condition to false
+			pPort->syncCondition = 0;
+			// send slave address
+			// a device of slave 0xff does not exist
+			// try to send nack signal to device that is holding the bus
+			R_I2C_DS = 0xFF;  // slave device stop nack
+			R_I2C_STAT = I2CSTAT_MASTER_RX; //Jan,08,2009 TX->RX by tukho.kim
+			// wait transmission
+			// Mar,05,2009  tukho.kim
+			retVal = wait_event_interruptible_timeout(pPort->syncQueue, pPort->syncCondition, 100);
+
+			if (retVal == -ERESTARTSYS) {
+				yield();
+				udelay(1000);
+			}
+			// Mar,05,2009  tukho.kim end
+			retry--;
+		}
+	}
+
+	retVal = 0;  // Mar,05,2009  tukho.kim 
+
+	if (I2CSTAT_BUSY) {
+		printk(KERN_EMERG "i2c %d port recovery is failed, check bus line\n", pPort->port);
+		retVal = -EIO;
+	} else
+	 	pPort->packet.status = STATUS_READY;
+
+	return retVal;
+}
+
+static int i2c_master_write(struct i2c_ctrl_t *pPort)
+{
+	int retVal = 0;
+	struct i2c_packet_t* pPacket = &pPort->packet;
+
+	u64 i2cTimeOut;	// Mar,04,2009  tukho.kim
+	int waitTime;	// Mar,05,2009  tukho.kim
+
+	R_I2C_CON = I2CCON_INT_EN(R_I2C_CON);
+	// ack not generate and check ack bit 
+	R_I2C_CON = I2CCON_GEN_NACK(R_I2C_CON);
+	// status write
+	pPacket->status = STATUS_WRITE;
+	// sync condition to false
+	pPort->syncCondition = 0;
+	// send slave address
+	R_I2C_DS = pPacket->slaveAddr;
+	R_I2C_STAT = I2CSTAT_MASTER_TX;
+
+	// wait transmission
+	// Mar,04,2009  tukho.kim
+	waitTime = wait_event_interruptible_timeout(pPort->syncQueue, pPort->syncCondition,
+			((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR));
+
+	switch (waitTime) {
+		case (0):
+			if (pPacket->subAddrSize || pPacket->dataSize) {
+				SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+				retVal = -EIO;   // Mar,05,2009  tukho.kim
+			}
+			break;
+
+		case (-ERESTARTSYS):
+			SSDTV_I2C_DPRINTK("I2C ERR: port %d -ERESTARTSYS is caused ==\n", pPort->port);
+			i2cTimeOut = jiffies + ((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR);
+			while (!pPort->syncCondition) {
+				yield();
+				if (jiffies > i2cTimeOut) {
+					SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+					retVal = -EIO;   // Mar,05,2009  tukho.kim
+					break;
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+	// Mar,04,2009  tukho.kim end
+
+	// check error status
+	if (pPacket->status & STATUS_ERROR_FLAG) {
+		SSDTV_I2C_DPRINTK("I2C ERR: port %d write error ================\n", pPort->port);
+		SSDTV_I2C_DPRINTK("I2C ERR: slave dev 0x%02x ================\n", pPacket->slaveAddr);
+		SSDTV_I2C_DPRINTK("I2C ERR: error status 0x%02x================\n", pPacket->status);
+		retVal = -EIO;
+	}	
+
+	return retVal;
+}
+
+static int i2c_master_read(struct i2c_ctrl_t *pPort)
+{
+	int retVal = 0;
+	struct i2c_packet_t* pPacket = &pPort->packet;
+
+	u64 i2cTimeOut = 0;  // Mar,04,2009  tukho.kim
+	int waitTime = 0;  // Mar,05,2009  tukho.kim
+
+	R_I2C_CON = I2CCON_INT_EN(R_I2C_CON);
+	// ack not generate and check ack bit 
+	R_I2C_CON = I2CCON_GEN_NACK(R_I2C_CON);
+	// status read
+	pPacket->status = STATUS_READ_START;
+	// sync condition to false
+	pPort->syncCondition = 0;
+	// send slave address
+	R_I2C_DS = pPacket->slaveAddr;
+	R_I2C_STAT = I2CSTAT_MASTER_RX;
+	// wait transfer
+	// Mar,04,2009  tukho.kim
+	waitTime = wait_event_interruptible_timeout(pPort->syncQueue, pPort->syncCondition,
+			((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR));
+
+	switch (waitTime) {
+		case (0):
+			if(pPacket->subAddrSize || pPacket->dataSize) {
+				SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+				retVal = -EIO;   // Mar,05,2009  tukho.kim
+			}
+			break;
+		case (-ERESTARTSYS):
+			SSDTV_I2C_DPRINTK("I2C ERR: port %d -ERESTARTSYS is caused ==\n", pPort->port);
+			i2cTimeOut = jiffies + ((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR);
+			while(!pPort->syncCondition) {
+				yield();
+				if (jiffies > i2cTimeOut) {
+					SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+					retVal = -EIO;	// Mar,05,2009  tukho.kim
+					break;
+				}
+			}
+			break;
+		default:
+			break;
+	}
+	// Mar,04,2009  tukho.kim end
+
+	// check error status
+	if (pPacket->status & STATUS_ERROR_FLAG) {
+		SSDTV_I2C_DPRINTK("I2C ERR: port %d read error ================\n", pPort->port);
+		SSDTV_I2C_DPRINTK("I2C ERR: slave dev 0x%02x not exist ========\n", pPacket->slaveAddr);
+		SSDTV_I2C_DPRINTK("I2C ERR: error status 0x%02x================\n", pPacket->status);
+		retVal = -EIO;
+	}
+
+	return retVal;
+}
+
+static int i2c_master_comb_read(struct i2c_ctrl_t *pPort)
+{
+	int retVal = 0;
+	u32 regVal = R_I2C_CON;
+	struct i2c_packet_t* pPacket = &pPort->packet;
+
+	u64 i2cTimeOut = 0;	// Mar,04,2009  tukho.kim
+	int waitTime = 0;	// Mar,05,2009  tukho.kim
+
+	regVal = I2CCON_INT_EN(regVal);
+	// ack not generate and check ack bit
+	R_I2C_CON = I2CCON_GEN_NACK(regVal);
+	// status write
+	pPacket->status = STATUS_READ_SUBADDR;
+	// sync condition to false
+	pPort->syncCondition = 0;
+	// send slave address
+	R_I2C_DS = pPacket->slaveAddr;
+	R_I2C_STAT = I2CSTAT_MASTER_TX;
+
+	// wait transmission
+	// Mar,04,2009  tukho.kim
+	waitTime = wait_event_interruptible_timeout(pPort->syncQueue, pPort->syncCondition,
+			((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR));
+
+	switch (waitTime) {
+		case (0):
+		// Timeout
+			if (pPacket->subAddrSize || pPacket->dataSize) {
+				SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+				retVal = -EIO;   // Mar,05,2009  tukho.kim
+			}
+			break;
+		// RestartSYS -> signal pending
+		case (-ERESTARTSYS):
+			SSDTV_I2C_DPRINTK("I2C ERR: port %d -ERESTARTSYS is caused ==\n", pPort->port);
+			i2cTimeOut = jiffies + ((pPacket->subAddrSize + pPacket->dataSize + 5) << WAIT_FACTOR);
+
+			while (!pPort->syncCondition) {
+				yield();
+				// Timeout
+				if (jiffies > i2cTimeOut) {
+					SSDTV_I2C_DPRINTK("I2C ERR: port %d write time out error ==\n", pPort->port);
+					retVal = -EIO;   // Mar,05,2009  tukho.kim
+					break;
+				}
+			}
+			break;
+		// normal operation
+		default:
+			break;
+	}
+	// Mar,04,2009  tukho.kim end
+
+	// check error status
+	if (pPacket->status & STATUS_ERROR_FLAG) {
+		SSDTV_I2C_DPRINTK("I2C ERR: port %d comb read error ================\n", pPort->port);
+		SSDTV_I2C_DPRINTK("I2C ERR: slave dev 0x%02x ================\n", pPacket->slaveAddr);
+		switch (pPacket->status & 0xBF) {
+			case STATUS_READ_SUBADDR_ERR:
+				SSDTV_I2C_DPRINTK("I2C ERR: slave not exist or =============\n");
+				SSDTV_I2C_DPRINTK("I2C ERR: sub address not ack ================\n");
+				break;
+			case STATUS_READ_START_ERR:
+				SSDTV_I2C_DPRINTK("I2C ERR: comb read start not ack ==============\n");
+				break;
+			default:
+				SSDTV_I2C_DPRINTK("I2C ERR: error status 0x%02x================\n", pPacket->status);
+				break;
+		}
+		retVal = -EIO;
+	}
+
+	return retVal;
+}
+
+static int ssdtv_i2c_MasterWrite(struct i2c_ctrl_t *pPort, u16 speedKhz)
+{
+	int retVal = 0;
+
+	retVal = i2c_check_bus(pPort);
+	if (retVal < 0)
+		goto __ssdtv_write_out;
+
+	retVal = i2c_set_clock(pPort, speedKhz);
+	if (retVal < 0)
+		goto __ssdtv_write_out;
+
+	retVal = i2c_master_write(pPort);
+
+
+__ssdtv_write_out:
+	if(pPort->packet.udelay)
+		udelay(pPort->packet.udelay);
+
+	return retVal;
+}
+
+static int ssdtv_i2c_MasterRead(struct i2c_ctrl_t* pPort, u16 speedKhz)
+{
+	int retVal = 0;
+
+	retVal = i2c_check_bus(pPort);
+	if (retVal < 0)
+		goto __ssdtv_read_out;
+
+	retVal = i2c_set_clock(pPort, speedKhz);
+	if (retVal < 0)
+		goto __ssdtv_read_out;
+
+	retVal = i2c_master_read(pPort);
+
+__ssdtv_read_out:
+	if (pPort->packet.udelay)
+		udelay(pPort->packet.udelay);
+
+	return retVal;
+}
+
+static int ssdtv_i2c_MasterCombRead(struct i2c_ctrl_t* pPort, u16 speedKhz)
+{
+	int retVal = 0;
+
+	retVal = i2c_check_bus(pPort);
+	if (retVal < 0) goto __ssdtv_combread_out;
+
+	retVal = i2c_set_clock(pPort, speedKhz);
+	if (retVal < 0) goto __ssdtv_combread_out;
+
+	retVal = i2c_master_comb_read(pPort);
+
+__ssdtv_combread_out:
+
+	if (pPort->packet.udelay)
+		udelay(pPort->packet.udelay);
+
+	return retVal;
+}
+
+static int ssdtv_i2c_MasterWriteNRead(struct i2c_ctrl_t *pPort, u16 speedKhz)
+{
+	int retVal = 0;
+	u16 rxDataSize = pPort->packet.dataSize;
+
+	retVal = i2c_check_bus(pPort);
+	if (retVal < 0)
+		goto __ssdtv_write_read_out;
+
+	retVal = i2c_set_clock(pPort, speedKhz);
+	if (retVal < 0)
+		goto __ssdtv_write_read_out;
+
+	pPort->packet.dataSize = 0;
+
+	retVal = i2c_master_write(pPort);
+	if (retVal < 0)
+		goto __ssdtv_write_read_out;
+
+	if (pPort->packet.udelay)
+		udelay(pPort->packet.udelay);
+
+	retVal = i2c_check_bus(pPort);
+	if (retVal < 0)
+		goto __ssdtv_write_read_out;
+
+	pPort->packet.dataSize = rxDataSize;
+
+	retVal = i2c_master_read(pPort);
+
+__ssdtv_write_read_out:
+
+	if (pPort->packet.udelay)
+		udelay(pPort->packet.udelay);
+
+	return retVal;
+}
+
+/* os dependent variable */
+static int major;
+static struct class *ssdtv_i2c_class;
+static struct cdev ssdtv_i2c_cdev;
+
+static int ssdtv_i2c_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long args)
+{
+	int retVal = 0;
+	u8 subAddr[4];
+	struct ssdtv_i2c_packet_t userPacket;
+	struct i2c_ctrl_t *pPort = (struct i2c_ctrl_t *)file->private_data;
+	struct i2c_packet_t *pPacket = &pPort->packet;
+
+	// Dec,23,2008  tukho.kim       increase data size for one packet to 2MB
+	u8 * largeDataBuffer = 0; // save page data buffer
+	u32  allocDataSize = 0;
+	
+	// get i2c arguement from spI in user region 
+	copy_from_user((void *)&userPacket, (void *)args, sizeof(struct ssdtv_i2c_packet_t));
+
+	// remove R/W bit 
+	userPacket.slaveAddr = userPacket.slaveAddr & 0xFE;
+
+	// 0xFE use at check_bus function 
+	if (userPacket.slaveAddr == 0xFE ) {
+		printk(KERN_WARNING "ssdtv i2c not support 0xFE address\n");
+		return -EINVAL;
+	}
+
+	down(&pPort->mutex);
+
+	// get micro delay time
+	pPacket->udelay = userPacket.udelay + 10; // margin 10us for 100khz device
+	// convert packet struct  
+	pPacket->slaveAddr = userPacket.slaveAddr;
+	pPacket->dataSize = userPacket.dataSize;
+	// debug mode not check Acknowledge
+	pPacket->reserve8 = userPacket.M_DEBUG;
+
+	DPRINTK_I2C_FLOW("dataSize is %d\n",pPacket->dataSize);
+
+	if (pPacket->dataSize > MAX_DATA_SIZE) {
+		printk(KERN_ERR "i2c data size(%d) is overflow\n", pPacket->dataSize);
+		printk(KERN_ERR "i2c Max data is %d\n", MAX_DATA_SIZE);
+		printk(KERN_ERR "You want to increase data size,change define MAX_DATA_SIZE in ssdtv_i2c.h");
+		retVal =  -EINVAL;
+		goto __ssdtv_i2c_ioctl_out;
+	}
+
+	pPacket->subAddrSize = userPacket.subAddrSize;
+	if (pPacket->subAddrSize > 4){
+		printk(KERN_ERR "i2c don't supprt over 4 sub address device\n");
+		retVal =  -EINVAL;
+		goto __ssdtv_i2c_ioctl_out;
+	}
+	if (pPacket->subAddrSize) {
+		pPacket->pSubAddr = subAddr;
+		copy_from_user(pPacket->pSubAddr, userPacket.pSubAddr, pPacket->subAddrSize);
+	}
+
+	// set data buffer region in transmission
+	// Dec,23,2008  tukho.kim       increase data size for one packet to 2MB
+	if (userPacket.dataSize > PAGE_DATA_SIZE) {
+		allocDataSize = userPacket.dataSize;
+		allocDataSize = (allocDataSize >> 12) + ((allocDataSize & 0xFFF) ? 1 : 0);
+		allocDataSize = allocDataSize << 12;
+
+		largeDataBuffer =  (u8 *)vmalloc((unsigned long)allocDataSize);
+
+		if (!largeDataBuffer) {
+			printk(KERN_ERR "i2c data buffer allocation failed %d: 0x%x\n", pPort->port, userPacket.slaveAddr);
+			goto __ssdtv_i2c_ioctl_out;
+		}
+		pPacket->pData	= largeDataBuffer;
+	} else
+		pPacket->pData	= pPort->pDataBuffer;
+	// Dec,23,2008  end
+
+	// execute command
+	switch (cmd){
+		case (I2C_CMD_WRITE):
+			if (pPacket->dataSize) {
+				copy_from_user(pPacket->pData, userPacket.pDataBuffer, pPacket->dataSize);
+			}
+			retVal = ssdtv_i2c_MasterWrite(pPort, userPacket.speedKhz);
+			if (retVal < 0) {
+				if (pPacket->subAddrSize == userPacket.subAddrSize)
+					SSDTV_I2C_DPRINTK("i2c device start byte not ack\n");
+				else if (pPacket->dataSize == userPacket.dataSize)
+					SSDTV_I2C_DPRINTK("i2c device sub address not ack\n");
+				else if (pPacket->dataSize)
+					SSDTV_I2C_DPRINTK("i2c device data %d not ack\n", userPacket.dataSize - pPacket->dataSize);
+				else 
+					SSDTV_I2C_DPRINTK("i2c device is hang\n");
+			}
+			break;
+		case (I2C_CMD_READ):
+			retVal = ssdtv_i2c_MasterRead(pPort, userPacket.speedKhz);
+			if (!(retVal < 0))
+				copy_to_user(userPacket.pDataBuffer, pPort->pDataBuffer, userPacket.dataSize);
+			else
+				SSDTV_I2C_DPRINTK("i2c device start byte not ack\n");
+			break;
+		case (I2C_CMD_COMBINED_READ):
+			retVal = ssdtv_i2c_MasterCombRead(pPort, userPacket.speedKhz);
+			if (!(retVal < 0))
+				copy_to_user(userPacket.pDataBuffer, pPort->pDataBuffer, userPacket.dataSize);
+			else {
+				if (pPacket->subAddrSize == userPacket.subAddrSize)
+					SSDTV_I2C_DPRINTK("i2c device start byte not ack\n");
+				else if (pPacket->dataSize == userPacket.dataSize)
+					SSDTV_I2C_DPRINTK("i2c device sub address not ack\n");
+				else 
+					SSDTV_I2C_DPRINTK("i2c device is hang\n");
+			}
+			break;
+		case (I2C_CMD_WRITE_N_READ):
+			retVal = ssdtv_i2c_MasterWriteNRead(pPort, userPacket.speedKhz);
+			if (!(retVal < 0))
+				copy_to_user(userPacket.pDataBuffer, pPort->pDataBuffer, userPacket.dataSize);
+			else {
+				if (pPacket->subAddrSize == userPacket.subAddrSize)
+					SSDTV_I2C_DPRINTK("i2c device start byte not ack\n");
+				else if (pPacket->dataSize == userPacket.dataSize)
+					SSDTV_I2C_DPRINTK("i2c device sub address not ack\n");
+				else 
+					SSDTV_I2C_DPRINTK("i2c device is hang\n");
+			}
+			break;
+		default:
+			printk(KERN_WARNING "i2c command 0x%02x error\n", cmd);
+			retVal = -EPERM;
+			break;
+	};
+
+
+__ssdtv_i2c_ioctl_out:
+	// Dec,23,2008  tukho.kim       increase data size for one packet to 2MB
+	if (!largeDataBuffer) {
+		vfree((void *)largeDataBuffer);
+		largeDataBuffer = 0; // Mar,04,2009  tukho.kim
+	}
+	// Dec,23,2008 end
+
+	up(&pPort->mutex);
+
+	return retVal;
+}
+
+static int ssdtv_i2c_open(struct inode *inode, struct file *file)
+{
+	int retVal = 0;
+	int port = iminor(inode);
+	struct i2c_ctrl_t *pPort = &i2c_ctrl[port];
+
+	file->private_data = (void*)pPort;
+	pPort->useCount++;
+
+	return retVal;
+}
+
+static int ssdtv_i2c_release (struct inode *inode, struct file *file)
+{
+	int retVal = 0;
+	struct i2c_ctrl_t *pPort = (struct i2c_ctrl_t *)file->private_data;
+
+	if (pPort->useCount > 0)
+		pPort->useCount--;
+
+	return retVal;
+}
+
+static const struct file_operations ssdtv_i2c_fops = {
+	.owner = THIS_MODULE,
+	.open  = ssdtv_i2c_open,
+	.release = ssdtv_i2c_release,
+	.ioctl = ssdtv_i2c_ioctl,
+};
+
+static int __devinit i2c_init(struct i2c_ctrl_t * pPort)
+{
+	int retVal = 0;
+
+	// check i2c bus status
+	if (i2c_check_bus(pPort) < 0) {
+		printk(KERN_ERR "i2c port %d is busy when initialize\n", pPort->port);
+		return -1;
+	}
+	// I2c port enable
+	R_I2C_STAT = I2CSTAT_BUS_ENABLE(0);
+
+	// set skew value
+	R_I2C_CONE = I2CCONE_SDA_SKEW(I2C_SDA_SKEW);
+
+	// initialize mutex resource 
+	init_MUTEX(&pPort->mutex);
+
+	// initialize synchronize resource 
+	init_waitqueue_head(&pPort->syncQueue);
+
+	// initialize data buffer resource 
+	// Dec,23,2008  tukho.kim       increase data size for one packet to 2MB
+	pPort->pDataBuffer = kmalloc(PAGE_DATA_SIZE, GFP_KERNEL);
+	if (!pPort->pDataBuffer)
+		return -1;
+
+	return retVal;
+}
+
+static int __devinit ssdtv_i2c_probe(struct platform_device *dev)
+{
+	int retVal = 0;
+
+	dev_t devId;
+	int i;
+	char drvName[64];
+	struct i2c_ctrl_t *pPort;
+	u32 vBase;
+
+	retVal = alloc_chrdev_region(&devId, 0, N_I2C_PORT, SSDTV_I2C_DRV_NAME);
+
+	if (retVal) {
+		printk(KERN_ERR "SSDTV i2c driver can't alloc device major number\n");
+		goto __out_err;
+	}
+
+	cdev_init(&ssdtv_i2c_cdev, &ssdtv_i2c_fops);
+	cdev_add(&ssdtv_i2c_cdev, devId, N_I2C_PORT);
+
+	ssdtv_i2c_class = class_create(THIS_MODULE, "ssdtv_i2c");
+
+	if (IS_ERR(ssdtv_i2c_class)) {
+		retVal = PTR_ERR(ssdtv_i2c_class);
+		cdev_del(&ssdtv_i2c_cdev);
+		goto __out_err;
+	}
+
+	major = MAJOR(devId);
+
+	// request i2c device register region, 4KByte(1 page)
+	vBase = (u32)ioremap_nocache (SSDTV_PERI_SFR_BASE,(1 << 12));
+	vPend = (vBase + SSDTV_I2C_SFR_OFFSET + O_I2C_PEND);
+
+	for (i = 0; i < N_I2C_PORT; i++){
+		// allocation resource 
+		pPort = &i2c_ctrl[i];
+		pPort->port = i;
+		pPort->vBase = (vBase + SSDTV_I2C_SFR_OFFSET +(i * 0x20));
+		if(i2c_init(pPort) < 0) continue;
+#ifndef I2C_IRQ_SHARED
+		request_irq(pPort->irq, i2c_interrupt_handler, 0, "ssdtv_i2c_irq", (void *)pPort);
+#endif
+		// device file create
+		sprintf(drvName, "%s%d", SSDTV_I2C_DRV_NAME, i);
+		class_device_create(ssdtv_i2c_class, NULL, MKDEV(major, i), NULL, drvName);
+		// output initialize result 
+		printk(KERN_INFO "SSDTV I2C %d port initialize base is 0x%08x\n", i, pPort->vBase);
+	}
+#ifdef I2C_IRQ_SHARED
+	request_irq(I2C_IRQ, i2c_interrupt_handler, 0, "ssdtv_i2c_irq", (void *)i2c_ctrl);
+#endif
+	goto __out;
+
+__out_err:
+	unregister_chrdev_region(devId, N_I2C_PORT);
+__out:
+	return retVal;
+}
+
+static int __devexit ssdtv_i2c_remove(struct platform_device *dev)
+{
+	int retVal = 0;
+
+	cdev_del(&ssdtv_i2c_cdev);
+	unregister_chrdev_region(MKDEV(major, 0), N_I2C_PORT);
+
+	return retVal;
+}
+
+
+static struct platform_device *ssdtv_i2c_platform_device;
+static struct platform_driver ssdtv_i2c_device_driver = {
+	.probe		= ssdtv_i2c_probe,
+	.remove		= __devexit_p(ssdtv_i2c_remove),
+	.driver		= {
+		.name	= "SSDTV_I2C",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ssdtv_i2c_init(void)
+{
+	int retVal;
+
+	ssdtv_i2c_platform_device = platform_device_alloc("SSDTV_I2C", -1);
+	if (!ssdtv_i2c_platform_device)
+		return -ENOMEM;
+
+	retVal = platform_device_add(ssdtv_i2c_platform_device);
+	if (retVal < 0) {
+		platform_device_put(ssdtv_i2c_platform_device);
+		return retVal;
+	}
+
+	retVal = platform_driver_register(&ssdtv_i2c_device_driver);
+
+	if (retVal < 0) {
+		platform_driver_unregister(&ssdtv_i2c_device_driver);
+		return retVal;
+	}
+
+	printk("Samsung SSDTV I2c ver %s access driver \n", DRV_VERSION);
+
+	return retVal;
+}
+
+static void __init ssdtv_i2c_exit(void)
+{
+	platform_driver_unregister(&ssdtv_i2c_device_driver);
+	platform_device_unregister(ssdtv_i2c_platform_device);
+}
+
+module_init(ssdtv_i2c_init);
+module_exit(ssdtv_i2c_exit);
+
+MODULE_LICENSE("GPL");
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_i2c.h new/arch/arm/mach-ssdtv/ssdtv_i2c.h
--- old/arch/arm/mach-ssdtv/ssdtv_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_i2c.h	2010-09-09 06:40:23.000000000 +0200
@@ -0,0 +1,119 @@
+/*********************************************************************************************
+ *
+ *	ssdtv_i2c.h (Samsung Soc i2c device driver without i2c layer in kernel)
+ *
+ *	author : tukho.kim@samsung.com
+ *	
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/drivers/char/ssdtv_i2c.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ ********************************************************************************************/
+/*********************************************************************************************
+ * Description 
+ * Date 	author		Description
+ * ----------------------------------------------------------------------------------------
+// Sep,06,2008 	tukho.kim	add delay between setting DS reg and Pending register clear
+// Sep,09,2008 	tukho.kim	ask to apply skew value '7' from VD division  
+// Dec,23,2008 	tukho.kim	increase data size for one packet to 2MB
+// Dec,24,2008 	tukho.kim	i2c check bus modify 
+ ********************************************************************************************/
+
+#ifndef __SSDTV_I2C_H
+#define __SSDTV_I2C_H
+
+#define I2C_SRC_CLK	140000 	// unit is Khz, 140000 Khz(140Mhz)
+#define I2C_IRQ_SHARED
+#define I2C_IRQ	24
+#define N_I2C_PORT	4
+#define O_I2C_PEND	0xE0
+#define I2C_SDA_SKEW	7  // Sep,09,2008 '1' -> '7'
+
+/* ssdtv i2c port base address, 4Kbyte mask - linux memory management*/
+#define SSDTV_PERI_SFR_BASE	(0x30090000)
+#define SSDTV_I2C_SFR_OFFSET	(0x100)
+
+/* ssdtv i2c driver name */
+#define SSDTV_I2C_DRV_NAME 	"sdp_i2c"
+
+/* Data buffer size */
+// Dec,23,2008 	tukho.kim	increase data size for one packet to 2MB
+// Add define PAGE_DATA_SIZE
+#define PAGE_DATA_SIZE	(1 << 12)	// 4096 byte, 4Kbyte 1page
+
+// Dec,23,2008 	tukho.kim	increase data size for one packet to 2MB
+// change value
+#define MAX_DATA_SIZE	(2 << 20)	// 2MB
+
+
+/* define status of i2c_packet_t */
+#define STATUS_READY			0x00	// ready
+#define STATUS_WRITE			0x01	// write, bus busy
+#define STATUS_READ_SUBADDR		0x11	// write, bus busy
+#define STATUS_READ_START		0x12	// read, bus busy
+#define STATUS_READ_DATA		0x13	// read, bus busy
+#define STATUS_TRY_READY		0x20    // use this at check_bus Dec,24,2008
+
+/* exception status */
+#define STATUS_ERROR_FLAG		0x80
+#define STATUS_STOP_DETECT		0x40	// none, bus ready
+
+#define STATUS_WRITE_ERR		0x81	// write, bus busy
+#define STATUS_READ_SUBADDR_ERR		0x91	// write, bus busy
+#define STATUS_READ_START_ERR		0x92	// read, bus busy
+#define STATUS_READ_DATA_ERR		0x93	// read, bus busy
+
+#define R_I2C_REG(offset)		(*(volatile unsigned int *)(pPort->vBase + offset))
+#define R_I2C_PEND			(*(volatile unsigned int *)(vPend))
+
+#define O_I2C_CON		(0x00)
+#define O_I2C_STAT		(0x04)
+#define O_I2C_ADD		(0x08)
+#define O_I2C_DS		(0x0C)
+#define O_I2C_CONE		(0x10)
+
+#define R_I2C_CON		R_I2C_REG(O_I2C_CON )
+#define R_I2C_STAT		R_I2C_REG(O_I2C_STAT)
+#define R_I2C_ADD		R_I2C_REG(O_I2C_ADD )
+#define R_I2C_DS		R_I2C_REG(O_I2C_DS  )
+#define R_I2C_CONE		R_I2C_REG(O_I2C_CONE)
+
+#define I2CCON_GEN_NACK(regval)		(regval & 0x0FF) 	//0x100	[8]
+#define I2CCON_GEN_ACK(regval)		(regval | 0x100)
+
+#define I2CCON_CLK_DIV16(regval)	(regval & 0x17F)	//0x080 [7]
+#define I2CCON_CLK_DIV256(regval)	(regval | 0x080)	
+
+#define I2CCON_INT_DIS(regval)		(regval & 0x1BF)	//0x040 [6]
+#define I2CCON_INT_EN(regval)		(regval | 0x040)
+
+#define I2CCON_CLK_PRE(val, regval)    ((regval & 0x3C0) | (val & 0x3F)) //0x3F [5:0]  // modify by tukho.kim 081014
+
+
+#define I2CSTAT_STOP_DETECT(regval)	(regval & 0x100)	//0x100 [8]
+#define I2CSTAT_STOP_FLAG_CLR		(0x100)			//0x100 [8]
+#define I2CSTAT_MASTER_RX		(0xB0)
+#define I2CSTAT_MASTER_RX_STOP		(0x90)
+#define I2CSTAT_MASTER_TX		(0xF0)
+#define I2CSTAT_MASTER_TX_STOP		(0xD0)
+#define I2CSTAT_STOP(regval)		(regval & 0x1DF)	//write '0' [5]
+#define I2CSTAT_START(regval)		(regval | 0x020)	//write '1' [5]
+#define I2CSTAT_BUSY			(R_I2C_STAT & (1 << 5)) //read [5]
+#define I2CSTAT_BUS_ENABLE(regVal)	(regVal | (1 << 4))
+#define I2CSTAT_RCV_NACK(regval)	(R_I2C_STAT & 1)
+
+#define I2CCONE_SDA_SKEW(regval)	(regval & 0xF)		//[3:0]
+
+// Sep,06,2008 add udelay(1)
+#define I2CPEND_CLEAR			( { volatile u32 val = R_I2C_PEND; \
+					     udelay(1); \
+					     R_I2C_PEND = (1 << pPort->port) & val; \
+					 } )
+
+#endif // __SSDTV_I2C_H
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_i2c_io.h new/arch/arm/mach-ssdtv/ssdtv_i2c_io.h
--- old/arch/arm/mach-ssdtv/ssdtv_i2c_io.h	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_i2c_io.h	2010-09-09 06:40:11.000000000 +0200
@@ -0,0 +1,49 @@
+/*********************************************************************************************
+ *
+ *	ssdtv_i2c_io.h (Samsung Soc i2c device driver ioctl arguement)
+ *
+ *	author : tukho.kim@samsung.com
+ *	
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/drivers/char/ssdtv_i2c_io.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ ********************************************************************************************/
+/*********************************************************************************************
+ * Description 
+// Dec,23,2008 	tukho.kim	increase data size for one packet to 2MB
+ ********************************************************************************************/
+
+#ifndef __SSDTV_I2C_IO_H
+#define __SSDTV_I2C_IO_H
+
+#define I2C_CMD_WRITE		0x01
+#define I2C_CMD_READ		0x02
+
+#define I2C_CMD_COMBINED_READ	0x11
+#define I2C_CMD_WRITE_N_READ	0x12
+
+/* define for debugging -> not check acknowledge*/
+#define M_DEBUG			reserve[0]
+#define DEBUG_ALWAYS_NOT_ACK 	0xA5
+
+struct ssdtv_i2c_packet_t {
+	unsigned char	slaveAddr;
+	unsigned char	subAddrSize;
+	unsigned short	udelay;
+	unsigned short 	speedKhz;
+	// Dec,23,2008 	tukho.kim	increase data size for one packet to 2MB
+	// unsigned short -> unsigned int 
+	unsigned int	dataSize;
+	unsigned char 	*pSubAddr;
+	unsigned char	*pDataBuffer;
+	unsigned char	reserve[4];
+};
+
+#endif // __SSDTV_I2C_IO_H
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_irq.c new/arch/arm/mach-ssdtv/ssdtv_irq.c
--- old/arch/arm/mach-ssdtv/ssdtv_irq.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_irq.c	2010-07-18 12:20:01.000000000 +0200
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2006 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_irq.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+
+#include <asm/delay.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/platform.h>
+
+#include "ssdtv_irq.h"
+
+static spinlock_t lockIrq;
+/* interrupt source is defined in machine header file */
+const static SSDTV_INT_T ssdtvInt_init[] = SSDTV_INTERRUPT_RESOURCE;
+
+static void ssdtv_enable_irq(unsigned int irq)
+{
+	INTMSK_UNMASK(irq);
+}
+
+static void ssdtv_disable_irq(unsigned int irq)
+{
+	INTMSK_MASK(irq);
+}
+
+static void ssdtv_ack_irq(unsigned int irq)
+{
+	INTPND_I_CLEAR(irq);	// offset 0x40
+}
+
+static void ssdtv_mask_irq(unsigned int irq)
+{
+	INTMSK_MASK(irq);	// masking
+	INTPND_I_CLEAR(irq);	// avoid to nesting same interrupt when using semi vectored interrupt 
+}
+
+static void ssdtv_unmask_irq(unsigned int irq)
+{
+	INTMSK_UNMASK(irq);
+}
+
+static struct irq_chip ssdtv_intctl = {
+	.enable = ssdtv_enable_irq,
+	.disable = ssdtv_disable_irq,
+	.ack	= ssdtv_ack_irq,
+	.mask	= ssdtv_mask_irq,
+	.unmask	= ssdtv_unmask_irq,
+};
+
+void __init ssdtv_init_irq(void)
+{
+	int i;
+	unsigned int polarity = 0, level = 0;
+
+	spin_lock_init(&lockIrq);
+
+	/* initialize interrupt controller */
+	R_SSDTV_INTC(SSDTV_INTC_INTCON) = INTCON_IRQ_FIQ_DIS;
+	R_SSDTV_INTC(SSDTV_INTC_INTMOD) = 0x00000000; // all irq mode 
+	R_SSDTV_INTC(SSDTV_INTC_INTMSK) = 0xFFFFFFFF; // all interrupt source mask
+	R_SSDTV_INTC(SSDTV_INTC_I_ISPC) = 0xFFFFFFFF; // irq status clear
+	R_SSDTV_INTC(SSDTV_INTC_F_ISPC) = 0xFFFFFFFF; // fiq status clear
+
+	for (i = 0; i < NR_IRQS; i++) {
+		polarity |= (ssdtvInt_init[i].polarity & 0x1) << i;
+		level    |= (ssdtvInt_init[i].level & 0x1) << i;
+	}
+	R_SSDTV_INTC(SSDTV_INTC_POLARITY) = polarity; // Polarity high
+	R_SSDTV_INTC(SSDTV_INTC_LEVEL) = level;  // Level configuration 
+
+	/* register interrupt resource */
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, &ssdtv_intctl);
+		if (ssdtvInt_init[i].level == LEVEL_EDGE)
+			set_irq_handler(i, handle_edge_irq);
+		else
+			set_irq_handler(i, handle_level_irq);
+
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+
+	R_SSDTV_INTC(SSDTV_INTC_INTCON) = INTCON_FIQ_DIS | INTCON_VECTORED;
+}
+
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_irq.h new/arch/arm/mach-ssdtv/ssdtv_irq.h
--- old/arch/arm/mach-ssdtv/ssdtv_irq.h	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_irq.h	2010-07-18 12:20:35.000000000 +0200
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2006 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_irq.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __SSDTV_INTC_H
+#define __SSDTV_INTC_H
+
+#ifndef VA_INTC_BASE
+#define SSDTV_INTC_BASE		VA_INT_BASE
+#else
+#define SSDTV_INTC_BASE		VA_INTC_BASE
+#endif
+
+#define INTCON		(0x00)
+#define INTPND		(0x04)
+#define INTMOD		(0x08)
+#define INTMSK		(0x0C)
+#define INT_LEVEL	(0x10)
+
+#define I_PSLV0		(0x14)
+#define I_PSLV1		(0x18)
+#define I_PSLV2		(0x1C)
+#define I_PSLV3		(0x20)
+#define I_PMST		(0x24)
+#define I_CSLV0		(0x28)
+#define I_CSLV1		(0x2C)
+#define I_CSLV2		(0x30)
+#define I_CSLV3		(0x34)
+// reserved		(0x38 ~ 3C)
+#define I_ISPC		(0x40)
+
+#define F_PSLV0		(0x44)
+#define F_PSLV1		(0x48)
+#define F_PSLV2		(0x4C)
+#define F_PSLV3		(0x50)
+#define F_PMST		(0x54)
+#define F_CSLV0		(0x58)
+#define F_CSLV1		(0x5C)
+#define F_CSLV2		(0x60)
+#define F_CSLV3		(0x64)
+// reserved		(0x68 ~ 6C)
+#define F_ISPC		(0x70)
+
+#define INT_POLARITY	(0x74)
+#define I_VECADDR	(0x78)
+#define F_VECADDR	(0x7C)
+
+#define INT_SRCPND	(0x90)
+
+#ifdef SSDTV_USING_SUBINT
+#define INT_SUBINT	(0x94)
+#endif
+
+#define INT_SRCSEL0	(0x98)
+#define INT_SRCSEL1	(0x9C)
+#define INT_SRCSEL2	(0xA0)
+#define INT_SRCSEL3	(0xA4)
+#define INT_SRCSEL4	(0xA8)
+#define INT_SRCSEL5	(0xAC)
+#define INT_SRCSEL6	(0xB0)
+#define INT_SRCSEL7	(0xB4)
+
+#define SSDTV_INTC_REG(x)	(SSDTV_INTC_BASE + x)
+#define R_SSDTV_INTC(x)		(*(volatile unsigned int *)x)
+
+#define SSDTV_INTC_INTCON	SSDTV_INTC_REG(INTCON)
+#define SSDTV_INTC_INTPND	SSDTV_INTC_REG(INTPND)
+#define SSDTV_INTC_INTMOD	SSDTV_INTC_REG(INTMOD)
+#define SSDTV_INTC_INTMSK	SSDTV_INTC_REG(INTMSK)
+#define SSDTV_INTC_LEVEL	SSDTV_INTC_REG(INT_LEVEL)
+
+#define SSDTV_INTC_I_PSLV0	SSDTV_INTC_REG(I_PSLV0)
+#define SSDTV_INTC_I_PSLV1	SSDTV_INTC_REG(I_PSLV1)
+#define SSDTV_INTC_I_PSLV2	SSDTV_INTC_REG(I_PSLV2)
+#define SSDTV_INTC_I_PSLV3	SSDTV_INTC_REG(I_PSLV3)
+#define SSDTV_INTC_I_PMST	SSDTV_INTC_REG(I_PMST)
+#define SSDTV_INTC_I_CSLV0	SSDTV_INTC_REG(I_CSLV0)
+#define SSDTV_INTC_I_CSLV1	SSDTV_INTC_REG(I_CSLV1)
+#define SSDTV_INTC_I_CSLV2	SSDTV_INTC_REG(I_CSLV2)
+#define SSDTV_INTC_I_CSLV3	SSDTV_INTC_REG(I_CSLV3)
+
+#define SSDTV_INTC_I_ISPC	SSDTV_INTC_REG(I_ISPC)
+
+#define SSDTV_INTC_F_PSLV0	SSDTV_INTC_REG(F_PSLV0)
+#define SSDTV_INTC_F_PSLV1	SSDTV_INTC_REG(F_PSLV1)
+#define SSDTV_INTC_F_PSLV2	SSDTV_INTC_REG(F_PSLV2)
+#define SSDTV_INTC_F_PSLV3	SSDTV_INTC_REG(F_PSLV3)
+#define SSDTV_INTC_F_PMST	SSDTV_INTC_REG(F_PMST)
+#define SSDTV_INTC_F_CSLV0	SSDTV_INTC_REG(F_CSLV0)
+#define SSDTV_INTC_F_CSLV1	SSDTV_INTC_REG(F_CSLV1)
+#define SSDTV_INTC_F_CSLV2	SSDTV_INTC_REG(F_CSLV2)
+#define SSDTV_INTC_F_CSLV3	SSDTV_INTC_REG(F_CSLV3)
+#define SSDTV_INTC_F_ISPC	SSDTV_INTC_REG(F_ISPC)
+
+#define SSDTV_INTC_POLARITY	SSDTV_INTC_REG(INT_POLARITY)
+#define SSDTV_INTC_I_VECADDR	SSDTV_INTC_REG(I_VECADDR)
+#define SSDTV_INTC_F_VECADDR	SSDTV_INTC_REG(F_VECADDR)
+
+#define SSDTV_INTC_SRCPND	SSDTV_INTC_REG(INT_SRCPND)
+
+#ifdef SSDTV_USING_SUBINT
+#define SSDTV_INTC_SUBINT	SSDTV_INTC_REG(INT_SUBINT)
+#endif
+
+#define SSDTV_INTC_SRCSEL0	SSDTV_INTC_REG(INT_SRCSEL0)
+#define SSDTV_INTC_SRCSEL1	SSDTV_INTC_REG(INT_SRCSEL1)
+#define SSDTV_INTC_SRCSEL2	SSDTV_INTC_REG(INT_SRCSEL2)
+#define SSDTV_INTC_SRCSEL3	SSDTV_INTC_REG(INT_SRCSEL3)
+#define SSDTV_INTC_SRCSEL4	SSDTV_INTC_REG(INT_SRCSEL4)
+#define SSDTV_INTC_SRCSEL5	SSDTV_INTC_REG(INT_SRCSEL5)
+#define SSDTV_INTC_SRCSEL6	SSDTV_INTC_REG(INT_SRCSEL6)
+#define SSDTV_INTC_SRCSEL7	SSDTV_INTC_REG(INT_SRCSEL7)
+
+#define INTCON_FIQ_DIS		(0x1)
+#define INTCON_IRQ_DIS		(0x1 << 1)
+#define INTCON_VECTORED		(0x1 << 2)
+#define INTCON_GMASK		(0x1 << 3)
+#define INTCON_IRQ_FIQ_DIS	(0x3)
+
+#define INTMSK_MASK(source) \
+	R_SSDTV_INTC(SSDTV_INTC_INTMSK) |= (1 << source)
+
+#define INTMSK_UNMASK(source) \
+	R_SSDTV_INTC(SSDTV_INTC_INTMSK) &= ~(1 << source)
+
+#define INTPND_I_CLEAR(source) \
+	R_SSDTV_INTC(SSDTV_INTC_I_ISPC) = (1 << source)
+	
+#define INTPND_F_CLEAR(source) \
+	R_SSDTV_INTC(SSDTV_INTC_F_ISPC) = (1 << source)
+
+#define POLARITY_LOW	1
+#define POLARITY_HIGH	0
+
+#define LEVEL_EDGE	0
+#define LEVEL_LEVEL	1
+
+typedef struct {
+	unsigned irqSrc:8;
+	unsigned qSrc:8;
+	unsigned level:8;
+	unsigned polarity:8;
+	unsigned int prioMask;
+	unsigned int subPrioMask;
+} SSDTV_INT_T;
+
+#endif // __SSDTV_INTC_H
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_pci.c new/arch/arm/mach-ssdtv/ssdtv_pci.c
--- old/arch/arm/mach-ssdtv/ssdtv_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_pci.c	2010-07-18 08:12:33.000000000 +0200
@@ -0,0 +1,409 @@
+/*
+ *  PCI functions for ssdtv host PCI bridge
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2007 Samsung Electronics.co
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_pci.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <asm/delay.h>
+
+#include <asm/arch/platform.h>
+
+#include "ssdtv_pci.h"
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(format, args...)	printk("%s[%d]\t" format, __FUNCTION__, __LINE__, ##args)
+#else
+#define DBG(format, args...)
+#endif
+
+#define DEBUG_BOARD
+
+#define MAX_SLOTS 21 /* AD11 ~ AD31 */
+
+static DEFINE_SPINLOCK(ssdtv_lock);
+
+static unsigned long ssdtv_open_config_window(struct pci_bus *bus, unsigned int devfn, int offset)
+{
+	unsigned int address, busnr;
+	u32 slot, func;
+
+	slot = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	busnr = bus->number;
+
+	/*
+	 * Trap out illegal values
+	 */
+	if (offset > 255)
+		BUG();
+	if (busnr > 255)
+		BUG();
+	if (devfn > 255)
+		BUG();
+
+	if(busnr == 0){
+		address = AHB_ADDR_PCI_CFG0(slot, func, offset);
+	} else {
+		address = AHB_ADDR_PCI_CFG1(busnr, slot, func, offset);
+	}
+	return address;
+}
+
+static void ssdtv_close_config_window(void)
+{
+	/*
+	 * Reassign base1 for use by prefetchable PCI memory
+	 */
+
+	/*
+	 * And shrink base0 back to a 256M window (NOTE: MAP0 already correct)
+	 */
+	mb();
+}
+
+static int ssdtv_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+			int size, u32 *val)
+{
+	unsigned long addr;
+	unsigned long flags;
+	u32 v;
+
+	spin_lock_irqsave(&ssdtv_lock, flags);
+	addr = ssdtv_open_config_window(bus, devfn, where);
+
+	switch (size) {
+	case 1:
+		v = ioread8(addr);
+		break;
+
+	case 2:
+		v = ioread16(addr);
+		break;
+
+	default:
+		v = ioread32(addr);
+		break;
+	}
+
+	ssdtv_close_config_window();
+	spin_unlock_irqrestore(&ssdtv_lock, flags);
+
+	*val = v;
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ssdtv_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+			int size, u32 val)
+{
+	unsigned long addr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ssdtv_lock, flags);
+	addr = ssdtv_open_config_window(bus, devfn, where);
+
+	switch (size) {
+	case 1:
+		iowrite8((u8)val, addr);
+		ioread8(addr);
+		break;
+
+	case 2:
+		iowrite16((u16)val, addr);
+		ioread16(addr);
+		break;
+
+	case 4:
+		iowrite32(val, addr);
+		ioread32(addr);
+		break;
+	}
+
+	ssdtv_close_config_window();
+	spin_unlock_irqrestore(&ssdtv_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static struct pci_ops pci_ssdtv_ops = {
+	.read	= ssdtv_read_config,
+	.write	= ssdtv_write_config,
+};
+
+
+static int ssdtv_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	unsigned long pc = instruction_pointer(regs);
+	unsigned long instr = *(unsigned long *)pc;
+
+	/*
+	 * If the instruction being executed was a read,
+	 * make it look like it read all-ones.
+	 */
+	if ((instr & 0x0c100000) == 0x04100000) {
+		int reg = (instr >> 12) & 15;
+		unsigned long val;
+
+		if (instr & 0x00400000)
+			val = 255;
+		else
+			val = -1;
+
+		regs->uregs[reg] = val;
+		regs->ARM_pc += 4;
+		return 0;
+	}
+
+	if ((instr & 0x0e100090) == 0x00100090) {
+		int reg = (instr >> 12) & 15;
+
+		regs->uregs[reg] = -1;
+		regs->ARM_pc += 4;
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static struct resource io_mem = {
+        .name   = "PCI I/O apeture",
+        .start  = AHB_PCI_IO_BASE,
+        .end    = AHB_PCI_IO_BASE + PCI_IO_SIZE -1,
+        .flags  = IORESOURCE_MEM,
+};
+static struct resource non_mem = {
+        .name   = "PCI MEM apeture",
+        .start  = AHB_PCI_MEM_BASE,
+        .end    = AHB_PCI_MEM_BASE + PCI_MEM_SIZE -1,
+        .flags  = IORESOURCE_MEM,
+};
+
+int __init pci_ssdtv_setup_resources(struct resource **resource)
+{
+	/*
+	 * Hook in our fault handler for PCI errors
+	 */
+
+	if (request_resource(&iomem_resource, &non_mem)) {
+		DBG(KERN_ERR "PCI: unable to allocate non-prefetchable memory region\n");
+		return -EBUSY;
+	}
+
+	if (request_resource(&iomem_resource, &io_mem)) {
+		release_resource(&non_mem);
+		DBG(KERN_ERR "PCI: unable to allocate I/O memory region\n");
+		return -EBUSY;
+	}
+	/*
+	 * bus->resource[0] is the IO resource for this bus
+	 * bus->resource[1] is the mem resource for this bus
+	 * bus->resource[2] is the prefetch mem resource for this bus
+	 */
+	resource[0] = &ioport_resource;
+	resource[1] = &non_mem;
+	resource[2] = NULL;
+
+	return 1;
+}
+
+/*
+ * These don't seem to be implemented on the Integrator I have, which
+ * means I can't get additional information on the reason for the pm2fb
+ * problems.  I suppose I'll just have to mind-meld with the machine. ;)
+ */
+
+int __init ssdtv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	int ret = 0;
+
+	if (nr == 0) {
+		sys->mem_offset = AHB_PCI_MEM_BASE;
+		ret = pci_ssdtv_setup_resources(sys->resource);
+	}
+
+	return ret;
+}
+
+struct pci_bus *ssdtv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	return pci_scan_bus(sys->busnr, &pci_ssdtv_ops, sys);
+}
+
+int __init ssdtv_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_PCI;
+}
+
+irqreturn_t ssdtv_pci_irq(int irq, void *devid, struct pt_regs *regs)
+{
+	unsigned long status;
+
+	status = R_PCIINTST & PINTST_CLEAR;
+
+	if (status & PINTST_PRD)
+		printk("[KERNEL] PCI reset is deasserted\n");
+	if (status & PINTST_PRA)
+		printk("[KERNEL] PCI reset is asserted\n");
+	if (status & PINTST_MFE) {
+		if (status & PINTST_RDE)
+			printk("[KERNEL] PCI/CardBus Master read fatal error \n");
+		if (status & PINTST_WDE)
+			printk("[KERNEL] PCI/CardBus Master write fatal error \n");
+		printk("Fatal Error PCI address 0x%08x\n", R_PCIINTAD);
+	}
+
+	if (status & PINTST_MPE) {
+		if (status & PINTST_RDE)
+			printk("[KERNEL] PCI/CardBus Master read parity error \n");
+		if (status & PINTST_WDE)
+			printk("[KERNEL] PCI/CardBus Master write parity error \n");
+		printk("Parity Error PCI address 0x%08x\n", R_PCIINTAD);
+	}
+
+	if (status & PINTST_TPE) {
+		if (status & PINTST_RDE)
+			printk("[KERNEL] PCI/CardBus Target read parity error \n");
+		if (status & PINTST_WDE)
+			printk("[KERNEL] PCI/CardBus Target write parity error \n");
+	}
+
+	if (status & PINTST_PME)
+		printk("[KERNEL] PCI PME# asserted\n");
+	if (status & PINTST_BPA)
+		printk("[KERNEL] PCI PCIBELPA[BEL] is set\n");
+	if (status & PINTST_SER)
+		printk("[KERNEL] PCI SERR# is asserted in host mode\n");
+	if (status & PINTST_AER)
+		printk("[KERNEL] PCI AHB Error response is detected\n");
+	if (status & PINTST_DME)
+		printk("[KERNEL] PCI DMA error\n");
+
+	R_PCIINTST = status;
+
+	return IRQ_HANDLED;
+}
+
+extern struct pci_ops pci_ssdtv_ops;
+
+void __init pci_ssdtv_pre_init(void)
+{
+	unsigned long flags;
+	unsigned int regVal;
+
+	spin_lock_irqsave(&ssdtv_lock, flags);
+
+	hook_fault_code(4, ssdtv_fault, SIGBUS, "external abort on linefetch");
+	hook_fault_code(6, ssdtv_fault, SIGBUS, "external abort on linefetch");
+	hook_fault_code(8, ssdtv_fault, SIGBUS, "external abort on non-linefetch");
+	hook_fault_code(10, ssdtv_fault, SIGBUS, "external abort on non-linefetch");
+
+	R_PCIINTEN = 0x00000000;
+	R_PCICON = 0x00000013;
+
+	/* PCIDIAG */
+	regVal = R_PCIDIAG0 & 0xFFFFFFF0;
+	regVal |= (1 << 2);
+
+	R_PCIDIAG0 = regVal;
+
+	/* PCIRCC */
+	regVal = R_PCIRCC & 0xFFFFFFF0;
+
+	/* assert internal reset (drive PCI_NRESET to low)
+	 * This is not useful when using external reset */
+	R_PCIRCC = regVal;	/* assert bus & logic reset signal */
+	R_PCIRCC = regVal | 3;	/* release bus & logic reset signal */
+
+	R_PCIBATAPM = 0x00000000; // PCI Memory Window Base
+	R_PCIBATAPI = 0x00000000; // PCI I/O Window Base
+	R_PCISET = 0x00000400;
+	
+	/* Memory Base Address 0 from PCI to AHB */
+	R_PCIBAM0 = ~(MACH_MEM0_SIZE - 1);
+	/* Base Address Translation */
+	R_PCIBATPA0 = MACH_MEM0_BASE;
+	/* location & size */
+	R_PCIHBAR0 = MACH_MEM0_BASE;
+
+	/* Memory Base Address 1 from PCI to AHB */
+	/* Base Address Mask */
+	R_PCIBAM1 = ~(MACH_MEM1_SIZE - 1);
+	/* Base Address Translation */
+	R_PCIBATPA1 = MACH_MEM1_BASE;
+	/* location & size disable */
+	R_PCIHBAR1 = MACH_MEM1_BASE;
+
+	/* I/O Base Address 2 from PCI to AHB */
+	/* Base Address Mask */
+	R_PCIBAM2 = 0xFFFFF000;
+	/* location & size disable */
+	R_PCIHBAR2 = 0x30030000;
+	/* Base Address Translation */
+	R_PCIBATPA2 = 0x30030000;
+
+	R_PCIHLINE = 0x00001008;
+
+	R_PCIHLTIT &= 0xffff0000;
+
+	/* Int Line:26(0x1a), Int Pin:INTA# */
+	R_PCIHLTIT |= 0x0000011A;
+
+	R_PCIHTIMER = 0x00008080;
+
+	/* I/O, Memory, Bus Master, ..., SERR Enable and Clear Status */
+	R_PCIHSC = 0x00000357;
+
+	R_PCICON = 0x00000393;
+
+	R_PCIINTEN = 0x0;
+
+	R_PCIINTST = PINTST_CLEAR;
+
+	request_irq(IRQ_PCI, ssdtv_pci_irq, SA_SHIRQ, "PCI irq", (void *)0xa700);
+
+	spin_unlock_irqrestore(&ssdtv_lock, flags);
+}
+
+void __init pci_ssdtv_post_init(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ssdtv_lock, flags);
+
+	R_PCIINTST = PINTST_CLEAR;
+	R_PCIINTEN = PINTEN_ALL_HOST;
+
+	spin_unlock_irqrestore(&ssdtv_lock, flags);
+}
+
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_pci.h new/arch/arm/mach-ssdtv/ssdtv_pci.h
--- old/arch/arm/mach-ssdtv/ssdtv_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_pci.h	2010-07-18 08:14:38.000000000 +0200
@@ -0,0 +1,168 @@
+/*
+ * Author: Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_pci.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __SSDTV_PCI_H
+#define __SSDTV_PCI_H
+
+#define PCI_MEM_ADDR			0x40000000
+#define PCI_IO_ADDR			0x00000000
+#define PCI_MEM_BAR0			0xC0000000
+#define PCI_MEM_BAR1			0xD0000000 + 0x0
+#define PCI_MEM_BAR2			0xD0000000 + 0x12000000
+
+#define PCI_MEM_SIZE			0x10000000
+#define PCI_IO_SIZE			0x04000000
+
+#define AHB_PCI_MEM_BASE		PCI_MEM_ADDR
+#define AHB_PCI_CONFIG_TYPE0_BASE	0x50000000
+#define AHB_PCI_CONFIG_TYPE1_BASE	0x54000000
+#define AHB_PCI_IO_BASE			0x5C000000
+
+#define PCI_CONFIG_TYPE0_VADDR		0xF0000000
+#define PCI_CONFIG_TYPE1_VADDR		0xF4000000
+
+#define  AHB_ADDR_PCI_CFG0( device, functn, offset )            \
+			(PCI_CONFIG_TYPE0_VADDR | ((device)<<11) | \
+			((    (functn)    &0x07)<< 8) | \
+			((    (offset)    &0xFF)    )   )
+#define  AHB_ADDR_PCI_CFG1( bus, device, functn, offset )       \
+			(PCI_CONFIG_TYPE1_VADDR | (((bus)&0xFF)<<16) | \
+			((    (device)    &0x1F)<<11) |\
+			((    (functn)    &0x07)<< 8) | \
+			((    (offset)    &0xFF)    )   )
+
+
+/* PCI Interrupt source mask */
+#define PINTEN_BAP  	(1 << 31)		/* Agent Only */
+/* Reserved [30:17] */
+#define PINTEN_AER    	(1 << 16)
+#define PINTEN_DE1    	(1 << 15)
+#define PINTEN_DM1    	(1 << 14)
+#define PINTEN_DE0    	(1 << 13)
+#define PINTEN_DM0    	(1 << 12)
+/* Reserved [11] */
+#define PINTEN_INA    	(1 << 10)
+#define PINTEN_SER    	(1 << 9)		/* Host Only */
+#define PINTEN_BPA    	(1 << 8)
+#define PINTEN_PSC    	(1 << 7)		/* Agent Only */
+#define PINTEN_PMC    	(1 << 6)		/* Agent Only */
+#define PINTEN_PME    	(1 << 5)
+#define PINTEN_TPE    	(1 << 4)
+#define PINTEN_MPE    	(1 << 3)
+#define PINTEN_MFE    	(1 << 2)
+#define PINTEN_PRA    	(1 << 1)
+#define PINTEN_PRD    	(1 << 0)
+
+#define PINTEN_ALL_HOST  (PINTEN_AER | PINTEN_INA | PINTEN_SER | PINTEN_BPA | PINTEN_PME | \
+		PINTEN_TPE | PINTEN_MPE | PINTEN_MFE | PINTEN_PRA | PINTEN_PRD )
+
+/* PCI Interrupt Status Register */
+#define PINTST_WDE		(1 << 31)
+#define PINTST_RDE		(1 << 30)
+#define PINTST_DME		(1 << 29)
+/* Reserved [28:17] */
+#define PINTST_AER		(1 << 16)
+#define PINTST_DE1		(1 << 15)
+#define PINTST_DM1		(1 << 14)
+#define PINTST_DE0		(1 << 13)
+#define PINTST_DM0		(1 << 12)
+/* Reserved [11] */
+#define PINTST_INA		(1 << 10)
+#define PINTST_SER		(1 << 9)
+#define PINTST_BPA		(1 << 8)
+#define PINTST_PSC		(1 << 7)
+#define PINTST_PMC		(1 << 6)
+#define PINTST_PME		(1 << 5)
+#define PINTST_TPE		(1 << 4)
+#define PINTST_MPE		(1 << 3)
+#define PINTST_MFE		(1 << 2)
+#define PINTST_PRA		(1 << 1)
+#define PINTST_PRD		(1 << 0)
+
+#define PINTST_CLEAR		(0x7FF | (0x1F << 12) | (0x7 << 29))
+
+/* PCI register bit */
+#define P_API       (25)
+#define P_APM       (27)
+
+/* PCI configuration */
+#define PCON_HST (1 << 0)
+#define PCON_ARB (1 << 1)
+#define PCON_ATS (1 << 4)
+#define PCON_SPL (1 << 5)
+#define PCON_IOP (1 << 6)
+#define PCON_MMP (1 << 7)
+#define PCON_CFD (1 << 8)
+#define PCON_RDY (1 << 9)
+
+#ifndef R_PCIHID
+#define R_PCIHID		rPCIHID
+#define R_PCIHSC		rPCIHSC
+#define R_PCIHCODE		rPCIHCODE
+#define R_PCIHLINE		rPCIHLINE
+#define R_PCIHBAR0		rPCIHBAR0
+#define R_PCIHBAR1		rPCIHBAR1
+#define R_PCIHBAR2		rPCIHBAR2
+/* Reserved */ 
+#define R_PCIHCISP		rPCIHCISP
+#define R_PCIHSSID		rPCIHSSID
+/* Reserved */
+#define R_PCIHCAP		rPCIHCAP
+/* Reserved */
+#define R_PCIHLTIT		rPCIHLTIT
+#define R_PCIHTIMER		rPCIHTIMER
+/* Reserved */
+#define R_PCIHPMR0		rPCIHPMR0
+#define R_PCIHPMR1		rPCIHPMR1
+
+#define R_PCICON		rPCICON	
+#define R_PCISET		rPCISET
+#define R_PCIINTEN		rPCIINTEN
+#define R_PCIINTST		rPCIINTST
+#define R_PCIINTAD		rPCIINTAD
+#define R_PCIBATAPM		rPCIBATAPM
+#define R_PCIBATAPI		rPCIBATAPI
+#define R_PCIRCC		rPCIRCC
+#define R_PCIDIAG0		rPCIDIAG0
+#define R_PCIDIAG1		rPCIDIAG1
+#define R_PCIBELAP		rPCIBELAP
+#define R_PCIBELPA		rPCIBELPA
+#define R_PCIMAIL0		rPCIMAIL0
+#define R_PCIMAIL1		rPCIMAIL1
+#define R_PCIMAIL2		rPCIMAIL2
+#define R_PCIMAIL3		rPCIMAIL3
+#define R_PCIBATPA0		rPCIBATPA0
+#define R_PCIBAM0		rPCIBAM0
+#define R_PCIBATPA1		rPCIBATPA1
+#define R_PCIBAM1		rPCIBAM1
+#define R_PCIBATPA2		rPCIBATPA2
+#define R_PCIBAM2		rPCIBAM2
+#define R_PCISWAP		rPCISWAP
+/* Reserved */
+#define R_PCIDMACON0		rPCIDMACON0
+#define R_PCIDMASRC0		rPCIDMASRC0
+#define R_PCIDMADST0		rPCIDMADST0
+#define R_PCIDMACNT0		rPCIDMACNT0
+#define R_PCIDMARUN0		rPCIDMARUN0
+/* Reserved */
+#define R_PCIDMACON1		rPCIDMACON1
+#define R_PCIDMASRC1		rPCIDMASRC1
+#define R_PCIDMADST1		rPCIDMADST1
+#define R_PCIDMACNT1		rPCIDMACNT1
+#define R_PCIDMARUN1		rPCIDMARUN1
+#endif
+
+#endif
diff -urNP old/arch/arm/mach-ssdtv/ssdtv_timer.c new/arch/arm/mach-ssdtv/ssdtv_timer.c
--- old/arch/arm/mach-ssdtv/ssdtv_timer.c	1970-01-01 01:00:00.000000000 +0100
+++ new/arch/arm/mach-ssdtv/ssdtv_timer.c	2010-07-18 08:08:35.000000000 +0200
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2006 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/plat-sdp/sdp_timer.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/mach/time.h>
+#include <asm/arch/platform.h>
+
+#ifndef R_TMDMASEL
+#define R_TMDMASEL		rTMDMASEL
+
+#define R_TMCON0		rTMCON0
+#define R_TMDATA0		rTMDATA0
+#define R_TMCNT0		rTMCNT0
+
+#define R_TMCON1		rTMCON1
+#define R_TMDATA1		rTMDATA1
+#define R_TMCNT1		rTMCNT1
+
+#define R_TMCON2		rTMCON2
+#define R_TMDATA2		rTMDATA2
+#define R_TMCNT2		rTMCNT2
+
+#define R_TMSTATUS		rTMSTATUS
+
+#define R_SYSTMCNT		rSYSTMCNT
+#define R_SYSTMCON		rSYSTMCON
+#define R_SYSTMDATA 		rSYSTMDATA
+#endif
+
+extern void clk_init(void);
+extern unsigned long SSDTV_GET_TIMERCLK(char mode);
+
+struct cal_usec {
+	unsigned long usec;
+	unsigned long nsec;
+};
+
+static unsigned int last_SYSTMCNT = 0;
+static struct cal_usec usecPerClk = {0, 0};
+
+// Calcuration about usec per 1 tick for another parts
+void ssdtv_get_time_tick(unsigned long *maxCount, unsigned long *pNsec)
+{
+	unsigned long timerSrcClk;
+	unsigned long nsec;
+
+	if (last_SYSTMCNT == 0) {
+		clk_init();
+
+	 	timerSrcClk = SSDTV_GET_TIMERCLK(TIMER_CLOCK) >> 2;
+
+		// timer scale is 1ns -> 1000000us * 1000
+		if ((SYS_TICK > 0) && (SYS_TICK <= 1000)) {
+			last_SYSTMCNT = (timerSrcClk / SYS_TICK / (SYS_TIMER_PRESCALER + 1));
+			nsec = 1000000000 / SYS_TICK / last_SYSTMCNT;
+		} else {
+			last_SYSTMCNT = (timerSrcClk / 100 / (SYS_TIMER_PRESCALER + 1));
+			nsec = 1000000000 / 100 / last_SYSTMCNT;
+		}
+
+		last_SYSTMCNT--;
+		usecPerClk.nsec = nsec % 1000;
+		usecPerClk.usec = nsec / 1000;
+
+		printk("Samsung SSDTV Timer Clock: %d.%03d usec per tick\n\tLoad value=%d\n", (int)usecPerClk.usec, (int)usecPerClk.nsec, last_SYSTMCNT);
+	} else {
+		nsec = (usecPerClk.usec * 1000) + usecPerClk.nsec;
+		printk("Samsung SSDTV Timer Clock: %d.%03d usec per tick\n\tLoad value=%d\n", (int)usecPerClk.usec, (int)usecPerClk.nsec, last_SYSTMCNT);
+	}
+
+	*maxCount = last_SYSTMCNT;
+	*pNsec = nsec;
+
+	return;
+}
+
+unsigned long ssdtv_timer_read(void)
+{
+	return R_SYSTMCNT;
+}
+
+static unsigned long ssdtv_gettimeoffset (void)
+{
+	unsigned long usec;
+	unsigned long nsec;
+	unsigned int pastCNT;
+	unsigned int currentCNT = R_SYSTMCNT;
+
+	// check timer interrupt 
+	if (R_TMSTATUS & SYS_TIMER_BIT)
+		return 1000000 / HZ;
+
+	// check timer reloading
+	if (currentCNT > last_SYSTMCNT)
+		return 0;
+ 
+	// calcurate usec delay
+	pastCNT = last_SYSTMCNT - currentCNT;
+
+	usec = (unsigned long)usecPerClk.usec * pastCNT;
+	nsec = (unsigned long)usecPerClk.nsec * pastCNT;
+	usec += nsec / 1000;
+
+	if ((nsec % 1000) > 499)
+		usec++;
+
+	return usec;
+}
+
+// interrupt service routine
+static irqreturn_t ssdtv_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	if (!(R_TMSTATUS & SYS_TIMER_BIT))
+		return IRQ_NONE;
+
+	R_TMSTATUS = SYS_TIMER_BIT;
+
+	write_seqlock(&xtime_lock);
+
+	timer_tick(regs);
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+// interrupt resource 
+static struct irqaction ssdtv_timer_irq = {
+	.name	= "SSDTV Timer tick",
+	.flags	= IRQF_SHARED | IRQF_DISABLED,
+	.handler = ssdtv_timer_interrupt
+};
+
+
+// Initailize the timer
+static void __init ssdtv_timer_init(void)
+{
+	unsigned long timerData, nsec;
+
+	printk(KERN_INFO "Samsung SSDTV Linux System timer initialize\n");
+
+	R_TMDMASEL = 0;
+
+	/* not have to do this */
+#ifdef R_TMCON0
+	R_TMCON0 = 0;
+#endif
+#ifdef R_TMCON1
+	R_TMCON1 = 0;
+#endif
+#ifdef R_TMCON2
+	R_TMCON2 = 0;
+#endif
+
+	R_SYSTMCON = TMCON_MUX04;
+
+	ssdtv_get_time_tick(&timerData, &nsec);
+
+	R_SYSTMDATA = timerData | (SYS_TIMER_PRESCALER << 16);
+
+	setup_irq(SYS_TIMER_IRQ, &ssdtv_timer_irq);
+
+	R_SYSTMCON |= TMCON_INT_DMA_EN;
+	R_SYSTMCON |= TMCON_RUN;
+}
+
+struct sys_timer ssdtv_timer = {
+	.init	= ssdtv_timer_init,
+	.offset	= ssdtv_gettimeoffset,
+};
+
diff -urNP old/arch/arm/mm/Kconfig new/arch/arm/mm/Kconfig
--- old/arch/arm/mm/Kconfig	2010-07-17 13:14:58.000000000 +0200
+++ new/arch/arm/mm/Kconfig	2010-07-17 13:21:19.000000000 +0200
@@ -345,7 +345,7 @@
 # ARMv6
 config CPU_V6
 	bool "Support ARM V6 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_SSDTV
 	select CPU_32v6
 	select CPU_ABRT_EV6
 	select CPU_CACHE_V6
diff -urNP old/arch/arm/mm/proc-v6.S new/arch/arm/mm/proc-v6.S
--- old/arch/arm/mm/proc-v6.S	2007-02-24 00:52:30.000000000 +0100
+++ new/arch/arm/mm/proc-v6.S	2010-07-17 13:21:19.000000000 +0200
@@ -17,6 +17,7 @@
 #include <asm/procinfo.h>
 #include <asm/pgtable-hwdef.h>
 #include <asm/pgtable.h>
+#include <asm/arch/proc-macros.S>
 
 #include "proc-macros.S"
 
@@ -66,7 +67,11 @@
  *	IRQs are already disabled.
  */
 ENTRY(cpu_v6_do_idle)
+#ifndef CONFIG_NOT_USE_WFI
 	mcr	p15, 0, r1, c7, c0, 4		@ wait for interrupt
+#else
+	wait_for_interrupt	r1, r2		@ arch-defined opreration
+#endif
 	mov	pc, lr
 
 ENTRY(cpu_v6_dcache_clean_area)
@@ -156,7 +161,7 @@
 
 
 cpu_v6_name:
-	.asciz	"Some Random V6 Processor"
+	.asciz	"ARMv6-compatible processor"
 	.align
 
 	.section ".text.init", #alloc, #execinstr
@@ -212,11 +217,26 @@
 	orr	r0, r0, #(0xf << 20)
 	mcr	p15, 0, r0, c1, c0, 2		@ Enable full access to VFP
 #endif
+	/* Workaround for the 364296 ARM1136 r0pX errata (possible cache data
+	 * corruption with hit-under-miss enabled). The conditional code below
+	 * (setting the undocumented bit 31 in the auxiliary control register
+	 * and the FI bit in the control register) disables hit-under-miss
+	 * without putting the processor into full low interrupt latency mode.
+	 */
+	ldr	r5, =0x4107b360			@ id for ARM1136 r0pX
+	mrc	p15, 0, r0, c0, c0, 0		@ get processor id
+	bic	r0, r0, #0xf			@ mask out part bits [3:0]
+	teq	r0, r5				@ check for the faulty core
+	mrceq	p15, 0, r0, c1, c0, 1		@ load aux control reg
+	orreq	r0, r0, #0x80000000		@ set bit 31
+	mcreq	p15, 0, r0, c1, c0, 1		@ write aux control reg
+
 	adr	r5, v6_crval
 	ldmia	r5, {r5, r6}
 	mrc	p15, 0, r0, c1, c0, 0		@ read control register
 	bic	r0, r0, r5			@ clear bits them
 	orr	r0, r0, r6			@ set them
+	orreq	r0, r0, #0x00200000		@ set the FI bit
 	mov	pc, lr				@ return to head.S:__ret
 
 	/*
diff -urNP old/arch/arm/tools/mach-types new/arch/arm/tools/mach-types
--- old/arch/arm/tools/mach-types	2007-02-24 00:52:30.000000000 +0100
+++ new/arch/arm/tools/mach-types	2010-08-29 18:52:17.000000000 +0200
@@ -1093,3 +1093,4 @@
 eti_b1			MACH_ETI_B1		ETI_B1			1080
 za9l_series		MACH_ZILOG_ZA9L		ZILOG_ZA9L		1081
 bit2440			MACH_BIT2440		BIT2440			1082
+ssdtv			MACH_SSDTV		SSDTV			10001
diff -urNP old/drivers/Makefile new/drivers/Makefile
--- old/drivers/Makefile	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/Makefile	2010-07-17 13:21:19.000000000 +0200
@@ -76,3 +76,4 @@
 obj-$(CONFIG_SUPERH)		+= sh/
 obj-$(CONFIG_GENERIC_TIME)	+= clocksource/
 obj-$(CONFIG_DMA_ENGINE)	+= dma/
+#obj-$(CONFIG_TINY_FSR)		+= tfsr/
diff -urNP old/drivers/net/8139too.c new/drivers/net/8139too.c
--- old/drivers/net/8139too.c	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/net/8139too.c	2010-07-17 13:21:19.000000000 +0200
@@ -87,6 +87,14 @@
 		"rtl8139-diag -mmmaaavvveefN" output
 		enable RTL8139_DEBUG below, and look at 'dmesg' or kernel log
 
+ *****************************************
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/drivers/net/8139too.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ *****************************************
+
 */
 
 #define DRV_NAME	"8139too"
@@ -1110,6 +1118,8 @@
 
 	assert (dev != NULL);
 
+	flush_scheduled_work();
+
 	unregister_netdev (dev);
 
 	__rtl8139_cleanup_dev (dev);
@@ -1377,6 +1387,15 @@
 
 	rtl8139_chip_reset (ioaddr);
 
+#if 1	// move before setting mac address by tukho.kim
+	/* init Rx ring buffer DMA address */
+	RTL_W32_F (RxBuf, tp->rx_ring_dma);
+
+	/* init Tx buffer DMA addresses */
+	for (i = 0; i < NUM_TX_DESC; i++)
+		RTL_W32_F (TxAddr0 + (i * 4), tp->tx_bufs_dma + (tp->tx_buf[i] - tp->tx_bufs));
+#endif
+
 	/* unlock Config[01234] and BMCR register writes */
 	RTL_W8_F (Cfg9346, Cfg9346_Unlock);
 	/* Restore our idea of the MAC address. */
@@ -1406,12 +1425,14 @@
 	/* Lock Config[01234] and BMCR register writes */
 	RTL_W8 (Cfg9346, Cfg9346_Lock);
 
+#if 0	// move before setting mac address by tukho.kim
 	/* init Rx ring buffer DMA address */
 	RTL_W32_F (RxBuf, tp->rx_ring_dma);
 
 	/* init Tx buffer DMA addresses */
 	for (i = 0; i < NUM_TX_DESC; i++)
 		RTL_W32_F (TxAddr0 + (i * 4), tp->tx_bufs_dma + (tp->tx_buf[i] - tp->tx_bufs));
+#endif
 
 	RTL_W32 (RxMissed, 0);
 
@@ -1576,11 +1597,10 @@
 				printk(KERN_INFO"%s: media is unconnected, link down, or incompatible connection\n",
 				       dev->name);
 			}
-#if 0
+/* SELP.arm.3.x support A1 2007-10-11 */
 			RTL_W8 (Cfg9346, Cfg9346_Unlock);
 			RTL_W8 (Config1, tp->mii.full_duplex ? 0x60 : 0x20);
 			RTL_W8 (Cfg9346, Cfg9346_Lock);
-#endif
 		}
 	}
 
@@ -1603,18 +1623,21 @@
 	struct rtl8139_private *tp = netdev_priv(dev);
 	unsigned long thr_delay = next_tick;
 
+	rtnl_lock();
+
+	if (!netif_running(dev))
+		goto out_unlock;
+
 	if (tp->watchdog_fired) {
 		tp->watchdog_fired = 0;
 		rtl8139_tx_timeout_task(_data);
-	} else if (rtnl_trylock()) {
-		rtl8139_thread_iter (dev, tp, tp->mmio_addr);
-		rtnl_unlock ();
-	} else {
-		/* unlikely race.  mitigate with fast poll. */
-		thr_delay = HZ / 2;
-	}
+	} else
+		rtl8139_thread_iter(dev, tp, tp->mmio_addr);
 
-	schedule_delayed_work(&tp->thread, thr_delay);
+	if (tp->have_thread)
+		schedule_delayed_work(&tp->thread, thr_delay);
+out_unlock:
+	rtnl_unlock();
 }
 
 static void rtl8139_start_thread(struct rtl8139_private *tp)
@@ -1626,19 +1649,11 @@
 		return;
 
 	tp->have_thread = 1;
+	tp->watchdog_fired = 0;
 
 	schedule_delayed_work(&tp->thread, next_tick);
 }
 
-static void rtl8139_stop_thread(struct rtl8139_private *tp)
-{
-	if (tp->have_thread) {
-		cancel_rearming_delayed_work(&tp->thread);
-		tp->have_thread = 0;
-	} else
-		flush_scheduled_work();
-}
-
 static inline void rtl8139_tx_clear (struct rtl8139_private *tp)
 {
 	tp->cur_tx = 0;
@@ -1695,8 +1710,9 @@
 {
 	struct rtl8139_private *tp = netdev_priv(dev);
 
+	tp->watchdog_fired = 1;
 	if (!tp->have_thread) {
-		INIT_WORK(&tp->thread, rtl8139_tx_timeout_task, dev);
+		INIT_WORK(&tp->thread, rtl8139_thread, dev);
 		schedule_delayed_work(&tp->thread, next_tick);
 	} else
 		tp->watchdog_fired = 1;
@@ -2130,14 +2146,15 @@
 	}
 
 	if (done) {
+		unsigned long flags;
 		/*
 		 * Order is important since data can get interrupted
 		 * again when we think we are done.
 		 */
-		local_irq_disable();
+		local_irq_save(flags);
 		RTL_W16_F(IntrMask, rtl8139_intr_mask);
 		__netif_rx_complete(dev);
-		local_irq_enable();
+		local_irq_restore(flags);
 	}
 	spin_unlock(&tp->rx_lock);
 
@@ -2232,8 +2249,6 @@
 
 	netif_stop_queue (dev);
 
-	rtl8139_stop_thread(tp);
-
 	if (netif_msg_ifdown(tp))
 		printk(KERN_DEBUG "%s: Shutting down ethercard, status was 0x%4.4x.\n",
 			dev->name, RTL_R16 (IntrStatus));
diff -urNP old/drivers/serial/Kconfig new/drivers/serial/Kconfig
--- old/drivers/serial/Kconfig	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/serial/Kconfig	2010-07-18 11:33:46.000000000 +0200
@@ -246,6 +246,16 @@
 
 comment "Non-8250 serial port support"
 
+config SERIAL_SSDTV
+	tristate "Samsung DTV serial port support"
+	depends on ARCH_SSDTV
+	select SERIAL_CORE
+
+config SERIAL_SSDTV_CONSOLE
+	bool "Support for console on Samsung DTV"
+	depends on SERIAL_SSDTV=y
+	select SERIAL_CORE_CONSOLE
+
 config SERIAL_AMBA_PL010
 	tristate "ARM AMBA PL010 serial port support"
 	depends on ARM_AMBA && (BROKEN || !ARCH_VERSATILE)
diff -urNP old/drivers/serial/Makefile new/drivers/serial/Makefile
--- old/drivers/serial/Makefile	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/serial/Makefile	2010-07-18 11:26:01.000000000 +0200
@@ -56,3 +56,4 @@
 obj-$(CONFIG_SERIAL_SGI_IOC3) += ioc3_serial.o
 obj-$(CONFIG_SERIAL_AT91) += at91_serial.o
 obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
+obj-$(CONFIG_SERIAL_SSDTV) += serial_ssdtv.o
diff -urNP old/drivers/serial/serial_ssdtv.c new/drivers/serial/serial_ssdtv.c
--- old/drivers/serial/serial_ssdtv.c	1970-01-01 01:00:00.000000000 +0100
+++ new/drivers/serial/serial_ssdtv.c	2010-07-18 11:25:46.000000000 +0200
@@ -0,0 +1,852 @@
+/*
+ * Copyright (C) 2006 Samsung Electronics.co
+ * Author : tukho.kim@samsung.com
+ *
+ */
+
+#define SSDTV_SERIAL_DEBUG
+//#undef SSDTV_SERIAL_DEBUG
+#define SERIAL_SSDTV_CONSOLE
+
+#if defined(SERIAL_SSDTV_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define  SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/mutex.h>
+
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/hardware.h>
+
+#include <asm/arch/platform.h>
+#include "serial_ssdtv.h"
+
+#define SSDTV_SERIAL_NAME	"ttyS"
+#define SSDTV_SERIAL_MAJOR	204
+#define SSDTV_SERIAL_MINOR	64
+
+#ifdef SSDTV_SERIAL_DEBUG
+#define SSDTV_SERIALD_NAME	"ttySD"
+#define SSDTV_SERIALD_MAJOR	SSDTV_SERIAL_MAJOR
+#define SSDTV_SERIALD_MINOR	(SSDTV_SERIAL_MINOR + SSDTV_UART_NR)
+#endif
+
+//port -> unused is unsigned character variable
+
+#define MODE_INTERRUPT		0
+#define MODE_POLLING		1
+#define MODE_METHOD_MASK	1
+
+#define MODE_CONSOLE		(0 << 4)
+#define MODE_DEBUG		(1 << 4)
+#define MODE_DEBUG_MASK		MODE_DEBUG
+
+#define MODE_NREQ_IRQ		(0 << 7)
+#define MODE_REQ_IRQ		(1 << 7)
+#define MODE_REQ_IRQ_MASK	MODE_REQ_IRQ
+
+/**************************************************
+ * Macros
+ **************************************************/
+#define UART_GET_CHAR(p)	__raw_readb((p)->membase + SSDTV_UARTRXH0_OFF)
+#define UART_PUT_CHAR(p,c)	__raw_writeb((c), (p)->membase + SSDTV_UARTTXH0_OFF)
+
+#define UART_GET_ULCON(p)	__raw_readl((p)->membase + SSDTV_UARTLCON_OFF)
+#define UART_GET_UCON(p)	__raw_readl((p)->membase + SSDTV_UARTCON_OFF)
+#define UART_GET_UFCON(p)	__raw_readl((p)->membase + SSDTV_UARTFCON_OFF)
+#define UART_GET_UMCON(p)	__raw_readl((p)->membase + SSDTV_UARTMCON_OFF)
+#define UART_GET_UBRDIV(p)	__raw_readl((p)->membase + SSDTV_UARTBRDIV_OFF)
+
+#define UART_GET_UTRSTAT(p)	__raw_readl((p)->membase + SSDTV_UARTTRSTAT_OFF)
+#define UART_GET_UERSTAT(p)	__raw_readl((p)->membase + SSDTV_UARTERSTAT_OFF)
+#define UART_GET_UFSTAT(p)	__raw_readl((p)->membase + SSDTV_UARTFSTAT_OFF)
+#define UART_GET_UMSTAT(p)	__raw_readl((p)->membase + SSDTV_UARTMSTAT_OFF)
+
+#define UART_PUT_UTRSTAT(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTTRSTAT_OFF)
+#define UART_PUT_ULCON(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTLCON_OFF)
+#define UART_PUT_UCON(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTCON_OFF)
+#define UART_PUT_UFCON(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTFCON_OFF)
+#define UART_PUT_UMCON(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTMCON_OFF)
+#define UART_PUT_UBRDIV(p,c)	__raw_writel(c, (p)->membase + SSDTV_UARTBRDIV_OFF)
+
+#define UART_RX_DATA(s)		(((s) & ssdtv_UTRSTAT_RXDR) == SSDTV_UTRSTAT_RXDR)
+#define UART_TX_READY(s)	(((s) & ssdtv_UTRSTAT_TXFE) == SSDTV_UTRSTAT_TXFE)
+#define TX_FIFOCOUNT(port)	(((UART_GET_UFSTAT(port)) >> 4) & 0xf)
+
+#define TX_ENABLED(port)	((port)->unused[0])
+#define UART_MODE(port)		((port)->unused[1])
+
+// serial debug code
+#ifdef SSDTV_SERIAL_DEBUG
+#define UART_DEBUG(port)	((port)->unused[2])
+
+static struct state_console_t {
+        unsigned int ulcon;
+        unsigned int ucon;
+        unsigned int ubrdiv;
+} stateConsole[SSDTV_UART_NR];
+#endif
+
+
+extern unsigned long
+SSDTV_GET_UARTCLK(char mode);
+
+extern void uart_parse_options(char *options, int *baud, int *parity, int *bits, int *flow);
+extern int uart_set_options(struct uart_port *port, struct console *co, int baud, int parity, int bits, int flow);
+static void ssdtv_serial_stop_tx(struct uart_port *port);
+
+static unsigned int ssdtv_serial_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count = 0;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return 0;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)){
+			ssdtv_serial_stop_tx(port);
+			return 0;
+		}
+
+		if (port->fifosize > 1)
+			count = (port->fifosize - (((UART_GET_UFSTAT(port) >> 4) & 0xF) + 1)); // avoid to overflow, fifo size
+		else
+			count = 1;
+
+	while (count > 0) {
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		count--;
+		if (uart_circ_empty(xmit)) {
+			ssdtv_serial_stop_tx(port);
+			break;
+		}
+	} 
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	return 0;
+}
+
+static unsigned int ssdtv_serial_rx_chars(struct uart_port *port)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, uerstat;
+	unsigned int ch, flag, max_count = 256;
+
+	if (port->fifosize > 1)
+		status = UART_GET_UFSTAT(port) & 0x10F;
+	else 
+		status = UART_GET_UTRSTAT(port) & 0x1;
+
+	uerstat = UART_GET_UERSTAT(port) & 0xF;
+
+	while (status && max_count--)
+	{
+		ch = UART_GET_CHAR(port);
+		flag = TTY_NORMAL;
+		uerstat = UART_GET_UERSTAT(port);
+
+		port->icount.rx++;
+
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+		uart_insert_char(port, uerstat, SSDTV_UERSTAT_OE, ch, flag); 
+ignore_char:
+		if (port->fifosize > 1)
+			status = UART_GET_UFSTAT(port) & 0x10F;
+		else 
+			status = UART_GET_UTRSTAT(port) & 0x1;
+	}
+
+	tty_flip_buffer_push(tty);
+
+	return 0;
+}
+
+static irqreturn_t ssdtv_uart_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int handled = 0;
+	struct uart_port *port = dev_id;
+	unsigned int utrstat; 
+
+	spin_lock(&port->lock);
+
+	utrstat = UART_GET_UTRSTAT(port);
+
+	if (utrstat & 0x30) {
+		if (utrstat & SSDTV_UTRSTAT_RXI) {
+			ssdtv_serial_rx_chars(port);
+			UART_PUT_UTRSTAT(port, 0x10);
+		}
+
+		if (utrstat & SSDTV_UTRSTAT_TXI) {
+			UART_PUT_UTRSTAT(port, 0x20);
+			ssdtv_serial_tx_chars(port);
+		}
+		handled = 1;
+	} else {
+		/* TODO: SDP92 has 1 shared irq line for 3 uart */
+	}
+
+	spin_unlock(&port->lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+
+// wait for the transmitter to empty
+static unsigned int ssdtv_serial_tx_empty(struct uart_port *port)
+{
+	return (UART_GET_UTRSTAT(port) & SSDTV_UTRSTAT_TXFE) ? TIOCSER_TEMT : 0;
+}
+
+static void  ssdtv_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	// don't support yet
+}
+
+static unsigned int ssdtv_serial_get_mctrl(struct uart_port *port)
+{
+	// don't support yet
+	unsigned int retVal = 0;
+
+	return retVal;
+}
+
+static void ssdtv_serial_stop_tx(struct uart_port *port)
+{
+#ifdef SSDTV_SERIAL_DEBUG
+	if (UART_MODE(port) & MODE_DEBUG) {
+		if (!UART_DEBUG(port))
+			return;
+	}
+#endif
+	TX_ENABLED(port) = 0;
+}
+
+static void ssdtv_serial_start_tx(struct uart_port *port)
+{
+	unsigned long flags;
+
+#ifdef SSDTV_SERIAL_DEBUG
+	// force to empty console buffer
+	struct circ_buf *xmit = &port->info->xmit;
+
+	if (UART_MODE(port) & MODE_DEBUG) {
+		if (!UART_DEBUG(port)) {
+			do {
+				xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+				port->icount.tx++;
+				if (uart_circ_empty(xmit)) {
+					break;
+				}
+			} while (1);
+			return;
+		}
+	}
+#endif
+
+	local_irq_save(flags);
+	local_irq_disable();
+	ssdtv_serial_tx_chars(port); // occur uart tx interrut event
+	local_irq_restore(flags);
+}
+
+static void ssdtv_serial_stop_rx(struct uart_port *port) {}
+
+/*
+ * Release IO and memory resources used by the port.
+ * This includes iounmap if necessary.
+ */
+
+static void ssdtv_serial_enable_ms(struct uart_port *port) {}
+
+// upper layer doesn't apply mutex
+static void ssdtv_serial_break_ctl(struct uart_port *port, int ctl)
+{
+	unsigned long ucon = UART_GET_UCON(port);
+
+	if (ctl)
+		ucon |= SSDTV_UCON_SBREAK;
+	else
+		ucon &= ~SSDTV_UCON_SBREAK;
+
+	UART_PUT_UCON(port,ucon);
+}
+
+static int ssdtv_serial_startup(struct uart_port *port)
+{
+	int retVal = 0;
+
+#ifdef SSDTV_SERIAL_DEBUG
+	// free console interrupt and requeset debug interrupt
+	struct uart_port *console_port;
+
+	if (UART_DEBUG(port)) {
+		console_port = port - SSDTV_UART_NR;
+		UART_MODE(console_port) &= ~MODE_DEBUG_MASK;
+		UART_MODE(console_port) |= MODE_DEBUG;
+
+		stateConsole[console_port->line].ucon = UART_GET_UCON(port);
+
+		UART_PUT_UCON(port, (UART_GET_UCON(port) & 0xFF));
+
+		while ((UART_GET_UTRSTAT(port) & 0x06) != 0x06);  // wait to empty of tx,rx buffer
+
+		UART_PUT_UTRSTAT(port, 0xF0);                   // clear interrupt flag
+
+		if (UART_MODE(console_port) & MODE_REQ_IRQ) {
+			free_irq(port->irq, console_port);
+		}
+	}
+#endif
+
+#ifdef IRQ_UART
+	retVal = request_irq(port->irq, ssdtv_uart_int, IRQF_SHARED, "ssdtv-serial", port);
+#else
+	retVal = request_irq(port->irq, ssdtv_uart_int, 0, "ssdtv-serial", port);
+#endif
+	if (retVal) 
+		return retVal;
+
+#ifdef SSDTV_SERIAL_DEBUG
+	// only check console port
+	if (!UART_DEBUG(port)) {
+		UART_MODE(port) &= ~MODE_REQ_IRQ_MASK;
+		UART_MODE(port) |= MODE_REQ_IRQ;
+	}
+#endif
+
+	if (port->fifosize > 1) { 	// fifo enable 
+		UART_PUT_UCON(port, 0x1085 | SSDTV_UCON_TXIE); // rx int, rx mode, rx count
+		UART_PUT_UFCON(port, 0x07); // fifo clear, fifo mode
+	} else {			// don't use fifo buffer
+		UART_PUT_UCON(port, 0x1005 | SSDTV_UCON_TXIE); // rx int, rx mode
+		UART_PUT_UFCON(port, 0x06); // fifo clear
+	}
+
+	UART_PUT_UMCON(port, 0);
+
+	if (port->uartclk == 0)
+		port->uartclk = SSDTV_GET_UARTCLK(UART_CLOCK);
+
+	UART_PUT_UBRDIV(port, (int)((port->uartclk >> 4) / (CURRENT_BAUD_RATE)) - 1);
+
+	return retVal;
+}
+
+static void ssdtv_serial_shutdown(struct uart_port *port)
+{
+	unsigned int ucon;
+
+	ucon = UART_GET_UCON(port) & 0xFF;
+	UART_PUT_UCON(port, ucon);
+
+	free_irq(port->irq, port);
+
+#ifdef SSDTV_SERIAL_DEBUG
+{
+	struct uart_port* console_port;
+
+	if (UART_DEBUG(port)) {
+		console_port = port - SSDTV_UART_NR;
+		UART_MODE(console_port) &= ~MODE_DEBUG_MASK;
+		UART_MODE(console_port) |= MODE_CONSOLE;
+
+		while ((UART_GET_UTRSTAT(port) & 0x06) != 0x06);  // wait to empty of tx,rx buffer
+
+		UART_PUT_UTRSTAT(port, 0xF0);                   // clear interrupt flag
+
+		if (UART_MODE(console_port) & MODE_REQ_IRQ) {
+			printk("recovery console port ISR \n");
+#ifdef IRQ_UART
+			request_irq(port->irq, ssdtv_uart_int, IRQF_SHARED, "ssdtv-uart", console_port);
+#else
+			request_irq(port->irq, ssdtv_uart_int, 0, "ssdtv-uart", console_port);
+#endif
+		}
+
+		UART_PUT_ULCON(console_port, stateConsole[console_port->line].ulcon);
+		UART_PUT_UBRDIV(console_port, stateConsole[console_port->line].ubrdiv);
+		UART_PUT_UCON(console_port, stateConsole[console_port->line].ucon);
+
+		printk("Debug port shutdown \n");
+	} else {
+		UART_MODE(port) &= ~MODE_REQ_IRQ_MASK;
+		UART_MODE(port) |= MODE_NREQ_IRQ;
+		UART_PUT_UCON(port, 0x4); // all disable, only tx enable for linux kernel
+	}
+}
+#endif
+}
+
+static void ssdtv_serial_set_termios(struct uart_port *port, struct termios *new, struct termios *old)
+{
+	unsigned int lcon;
+	unsigned int baud, quot;
+
+	baud = uart_get_baud_rate(port, new, old, 2400, 115200);
+	quot = (port->uartclk >> 4) / baud - 1;
+
+	lcon = UART_GET_ULCON(port);
+	switch (new->c_cflag & CSIZE) {
+		case CS5:
+			lcon |= SSDTV_LCON_CS5;
+			break;
+		case CS6:
+			lcon |= SSDTV_LCON_CS6;
+			break;
+		case CS7:
+			lcon |= SSDTV_LCON_CS7;
+			break;
+		default:
+			lcon |= SSDTV_LCON_CS8;
+			break;
+	}
+
+	if (new->c_cflag & PARENB) {
+		lcon |= (new->c_iflag & PARODD) ? SSDTV_LCON_PODD : SSDTV_LCON_PEVEN;
+	} else {
+		lcon |= SSDTV_LCON_PNONE;
+	}
+
+	UART_PUT_ULCON(port, lcon);
+	if (new->c_iflag & BRKINT) {
+		unsigned long ucon = UART_GET_UCON(port);
+		ucon |= SSDTV_UCON_SBREAK;
+		UART_PUT_UCON(port, ucon);
+	}
+
+	UART_PUT_UBRDIV(port, quot);
+
+#ifdef SSDTV_SERIAL_DEBUG
+	if (!UART_DEBUG(port)) {
+		stateConsole[port->line].ulcon = UART_GET_ULCON(port);
+		stateConsole[port->line].ubrdiv = UART_GET_UBRDIV(port);
+	}
+#endif
+}
+
+static const char *ssdtv_serial_type(struct uart_port *port)
+{
+	return (port->type == PORT_SSDTV) ? "SSDTV" : NULL;
+}
+
+/*
+ * Release IO and memory resources used by the port.
+ * This includes iounmap if necessary.
+ */
+static void ssdtv_serial_release_port(struct uart_port *port)
+{
+	printk(KERN_NOTICE "enter serial_release\n" );
+}
+
+/*
+ * Request IO and memory resources used by the port.
+ * This includes iomapping the port if necessary.
+ */
+static int ssdtv_serial_request_port(struct uart_port *port)
+{
+	printk(KERN_NOTICE "enter serial_request_port\n" );
+	return 0;
+}
+static void ssdtv_serial_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE && ssdtv_serial_request_port(port) == 0)
+		port->type = PORT_SSDTV;
+}
+static int ssdtv_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int retVal = 0;
+
+	return retVal;
+}
+
+#ifdef CONFIG_SERIAL_SSDTV_CONSOLE
+static struct console ssdtv_serial_console;
+#define SSDTV_SERIAL_CONSOLE	&ssdtv_serial_console
+#else
+#define SSDTV_SERIAL_CONSOLE	NULL
+#endif
+
+#ifndef SSDTV_SERIAL_DEBUG
+static struct uart_port ssdtv_ports[SSDTV_UART_NR];
+#else
+static struct uart_port ssdtv_ports[SSDTV_UART_NR << 1];
+#endif
+
+static struct uart_ops ssdtv_serial_ops = {
+	.tx_empty	= ssdtv_serial_tx_empty,
+	.set_mctrl	= ssdtv_serial_set_mctrl,
+	.get_mctrl	= ssdtv_serial_get_mctrl,
+	.stop_tx	= ssdtv_serial_stop_tx,
+	.start_tx	= ssdtv_serial_start_tx,
+	.send_xchar	= NULL,
+	.stop_rx	= ssdtv_serial_stop_rx,
+	.enable_ms	= ssdtv_serial_enable_ms, 
+	.break_ctl	= ssdtv_serial_break_ctl,
+	.startup	= ssdtv_serial_startup,
+	.shutdown	= ssdtv_serial_shutdown,
+	.set_termios	= ssdtv_serial_set_termios,
+	.pm		= NULL,
+	.set_wake	= NULL,
+	.type		= ssdtv_serial_type,
+	.release_port	= ssdtv_serial_release_port,
+	.request_port	= ssdtv_serial_request_port,
+	.config_port	= ssdtv_serial_config_port,
+	.verify_port	= ssdtv_serial_verify_port,
+	.ioctl		= NULL,
+};
+
+static struct uart_driver ssdtv_uart_drv = {
+	.owner			= THIS_MODULE,
+	.dev_name 		= "ssdtv_serial",
+	.dev_name 		= SSDTV_SERIAL_NAME,
+	.nr			= SSDTV_UART_NR,
+	.cons			= SSDTV_SERIAL_CONSOLE,
+	.driver_name		= SSDTV_SERIAL_NAME,
+	.major			= SSDTV_SERIAL_MAJOR,
+	.minor			= SSDTV_SERIAL_MINOR,
+};
+
+#ifdef SSDTV_SERIAL_DEBUG
+static struct uart_driver ssdtv_uartd_drv = {
+	.owner			= THIS_MODULE,
+	.dev_name		= SSDTV_SERIALD_NAME,
+	.nr			= SSDTV_UART_NR,
+	.cons			= NULL,
+	.driver_name		= SSDTV_SERIALD_NAME,
+	.major			= SSDTV_SERIALD_MAJOR,
+	.minor			= SSDTV_SERIALD_MINOR,
+};
+#endif
+
+static int ssdtv_serial_probe(struct platform_device *dev)
+{
+	struct device *_dev = &dev->dev;
+	struct resource *res = NULL;
+	int i;
+	int found = 0;
+
+	for (i = 0; i < dev->num_resources; i++) {
+		struct resource *tmp = &dev->resource[i];
+		if (tmp->flags & IORESOURCE_MEM) {
+			res = tmp;
+			break;
+		}
+	}
+
+	if (res) {
+		for (i = 0; i < SSDTV_UART_NR; i++) {
+			if (ssdtv_ports[i].mapbase != res->start) {
+				continue;
+			}
+			ssdtv_ports[i].dev = _dev;
+			uart_add_one_port(&ssdtv_uart_drv, &ssdtv_ports[i]);
+			dev_set_drvdata(_dev, &ssdtv_ports[i]);
+#ifdef SSDTV_SERIAL_DEBUG
+			ssdtv_ports[i + SSDTV_UART_NR].dev = _dev;
+                        uart_add_one_port(&ssdtv_uartd_drv, &ssdtv_ports[i + SSDTV_UART_NR]);
+			dev_set_drvdata(_dev, &ssdtv_ports[i + SSDTV_UART_NR]);
+#endif
+			found = 1;
+                        break;
+		}
+	}
+
+	if (found)
+		return 0;
+	else
+		return -ENODEV;
+}
+
+static int ssdtv_serial_remove(struct platform_device *dev)
+{
+	struct uart_port *port = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+	if (port) {
+#ifdef SSDTV_SERIAL_DEBUG
+		if (UART_DEBUG(port))
+			uart_remove_one_port(&ssdtv_uartd_drv, port);
+		else
+#endif
+			uart_remove_one_port(&ssdtv_uart_drv, port);
+	}
+
+	return 0;
+}
+
+static int ssdtv_serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uart_port *port = platform_get_drvdata(dev);
+#ifdef SSDTV_SERIAL_DEBUG
+	if (UART_DEBUG(port))
+		uart_suspend_port(&ssdtv_uartd_drv, port);
+	else
+#endif
+		uart_suspend_port(&ssdtv_uart_drv, port);
+
+	return 0;
+}
+
+static int ssdtv_serial_resume(struct platform_device *dev)
+{
+	struct uart_port *port = platform_get_drvdata(dev);
+#ifdef SSDTV_SERIAL_DEBUG
+	if (UART_DEBUG(port))
+		uart_resume_port(&ssdtv_uartd_drv, port);
+        else
+#endif
+		uart_resume_port(&ssdtv_uart_drv, port);
+
+	return 0;
+}
+
+static struct platform_driver ssdtv_serial_driver = {
+	.probe		= ssdtv_serial_probe,
+	.remove		= ssdtv_serial_remove,
+	.suspend	= ssdtv_serial_suspend,
+	.resume		= ssdtv_serial_resume,
+	.driver		= {
+		.name 	= "ssdtv-uart",
+		.owner 	= THIS_MODULE,
+	},
+};
+
+static void __init ssdtv_init_port(void)
+{
+	static int first = 1;
+	int i;
+#ifdef SSDTV_SERIAL_DEBUG
+        int j = SSDTV_UART_NR;
+#endif
+#ifdef IRQ_UART
+	int uart_irq = IRQ_UART;
+#else
+	int uart_irq[SSDTV_UART_NR] = { IRQ_UART0, IRQ_UART1, IRQ_UART2 };
+#endif
+
+	if (!first)
+		return;
+
+	first = 0;
+
+	for (i = 0; i < SSDTV_UART_NR; i++) {
+		ssdtv_ports[i].membase	 = (void *)(VA_UART_BASE + (SSDTV_UART_GAP * i));
+		ssdtv_ports[i].mapbase	 = (PA_UART_BASE + (SSDTV_UART_GAP * i));
+		ssdtv_ports[i].iotype	 = SERIAL_IO_MEM;
+		ssdtv_ports[i].uartclk	 = SSDTV_GET_UARTCLK(UART_CLOCK);
+		ssdtv_ports[i].fifosize	 = 16;
+		ssdtv_ports[i].timeout	 = HZ / 50;
+		ssdtv_ports[i].unused[0] = 0;
+		ssdtv_ports[i].unused[1] = 0;
+		ssdtv_ports[i].unused[2] = 0;
+		ssdtv_ports[i].ops	 = &ssdtv_serial_ops;
+		ssdtv_ports[i].flags	 = ASYNC_BOOT_AUTOCONF;
+		ssdtv_ports[i].type	 = PORT_SSDTV;
+		ssdtv_ports[i].line      = i;
+#ifdef IRQ_UART
+		ssdtv_ports[i].irq	 = uart_irq;
+#else
+		ssdtv_ports[i].irq	 = uart_irq[i];
+#endif
+		/* add by tukho.kim 20061113, kernel version upgrade -> 2.6.17 */
+                ssdtv_ports[i].ignore_status_mask = 0xE;
+		/* GDB bug fix 20071018 */
+                ssdtv_ports[i].timeout	 = HZ / 50;
+	}
+#ifdef SSDTV_SERIAL_DEBUG
+	for (j = SSDTV_UART_NR; j < (SSDTV_UART_NR << 1); j++) {
+		i = j - SSDTV_UART_NR;
+		ssdtv_ports[j].membase	 = (void *)(VA_UART_BASE + (SSDTV_UART_GAP * i));
+		ssdtv_ports[j].mapbase	 = (PA_UART_BASE + (SSDTV_UART_GAP * i));
+		ssdtv_ports[j].iotype	 = SERIAL_IO_MEM;
+		ssdtv_ports[j].uartclk	 = SSDTV_GET_UARTCLK(UART_CLOCK);
+		ssdtv_ports[j].fifosize	 = 16;
+		ssdtv_ports[j].unused[0] = 0;
+		ssdtv_ports[j].unused[1] = 0;
+		ssdtv_ports[j].unused[2] = 1;
+		ssdtv_ports[j].ops	 = &ssdtv_serial_ops;
+		ssdtv_ports[j].flags	 = ASYNC_BOOT_AUTOCONF;
+		ssdtv_ports[j].type	 = PORT_SSDTV;
+		ssdtv_ports[j].line	 =  i;
+		ssdtv_ports[j].ignore_status_mask = 0xE;
+#ifdef IRQ_UART
+		ssdtv_ports[j].irq	 = uart_irq;
+#else
+		ssdtv_ports[j].irq	 = uart_irq[i];
+#endif
+		/* GDB bug fix 20071018 */
+		ssdtv_ports[j].timeout	 = HZ / 50;
+	}
+#endif
+
+	for (i = 0; i< SSDTV_UART_NR; i++) {
+		/* Tx Rx disable interrupt */
+		UART_PUT_UCON(&ssdtv_ports[i], 0x4);	// only tx enable
+		/* Clear all interrupt status */
+		UART_PUT_UTRSTAT(&ssdtv_ports[i], 0xF0);
+	}
+}
+
+static int __init ssdtv_serial_modinit(void)
+{
+	int retVal = 0;
+
+	printk(KERN_INFO "Serial: SDP driver $Revision : 1.10 $\n");
+
+	ssdtv_init_port();
+
+	retVal = uart_register_driver(&ssdtv_uart_drv);
+#ifdef SSDTV_SERIAL_DEBUG
+	if (retVal == 0) {
+		retVal = uart_register_driver(&ssdtv_uartd_drv);
+		if (retVal)
+			uart_unregister_driver(&ssdtv_uart_drv);
+	}
+#endif
+
+	if (retVal) 
+		goto out;
+
+	retVal = platform_driver_register(&ssdtv_serial_driver);
+	if (retVal == 0)
+		goto out;
+
+	uart_unregister_driver(&ssdtv_uart_drv);
+#ifdef SSDTV_SERIAL_DEBUG
+	uart_unregister_driver(&ssdtv_uartd_drv);
+#endif
+out:
+	return retVal;
+}
+
+static void __exit ssdtv_serial_modexit(void) {
+	platform_driver_unregister(&ssdtv_serial_driver);
+	uart_unregister_driver(&ssdtv_uart_drv);
+#ifdef SSDTV_SERIAL_DEBUG
+	uart_unregister_driver(&ssdtv_uartd_drv);
+#endif
+}
+
+module_init(ssdtv_serial_modinit);
+module_exit(ssdtv_serial_modexit);
+
+#ifdef SERIAL_SSDTV_CONSOLE
+static void ssdtv_console_write(struct console *co, const char *s, unsigned count)
+{
+	struct uart_port *port = ssdtv_ports + co->index;
+	int i, status;
+	unsigned int ucon;
+
+#ifdef SSDTV_SERIAL_DEBUG
+	if (UART_MODE(port) & MODE_DEBUG)
+		return;
+#endif
+	ucon = UART_GET_UCON(port);
+
+	UART_PUT_UCON(port, (ucon & ~(SSDTV_UCON_TXIE) ));
+
+	/*
+	 *      Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		while( (UART_GET_UTRSTAT(port) & 0x2) != 0x2 )
+			continue/*nop*/;
+		UART_PUT_CHAR(port, (s[i]) & 0xff);
+
+		if (s[i] == '\n') {
+			while( (UART_GET_UTRSTAT(port) & 0x2) != 0x2 )
+				continue/*nop*/;
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+	/* Clear TX Int status */
+	status = UART_GET_UTRSTAT(port);
+	UART_PUT_UTRSTAT(port, (status & 0x0F) | SSDTV_UTRSTAT_TXI);
+
+	UART_PUT_UCON(port, ucon);
+}
+
+static void __init ssdtv_uart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	*baud = CURRENT_BAUD_RATE;
+	*bits = 8;
+	*parity = 'n';
+}
+
+static int __init ssdtv_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = CURRENT_BAUD_RATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= SSDTV_UART_NR) {
+		co->index = 0;
+	}
+
+	port = ssdtv_ports + co->index;
+
+	ssdtv_init_port();
+
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	} else {
+		ssdtv_uart_console_get_options(port, &baud, &parity, &bits);
+	}
+
+	UART_PUT_UCON(port, 0x04);  // Tx mode setting(Interrupt request or polling mode)
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console ssdtv_serial_console = {
+	.name 		= SSDTV_SERIAL_NAME,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.write		= ssdtv_console_write,
+	.read		= NULL,
+	.setup		= ssdtv_console_setup,
+	.data		= &ssdtv_uart_drv,
+};
+
+static int __init ssdtv_serial_initconsole(void)
+{
+	register_console(&ssdtv_serial_console);
+	return 0;
+}
+
+console_initcall(ssdtv_serial_initconsole);
+
+#endif /* SERIAL_SSDTV_CONSOLE */
+
+MODULE_AUTHOR("tukho.kim@samsung.com");
+MODULE_DESCRIPTION("Samsung SDP Serial port driver");
+
diff -urNP old/drivers/serial/serial_ssdtv.h new/drivers/serial/serial_ssdtv.h
--- old/drivers/serial/serial_ssdtv.h	1970-01-01 01:00:00.000000000 +0100
+++ new/drivers/serial/serial_ssdtv.h	2010-07-18 09:51:26.000000000 +0200
@@ -0,0 +1,95 @@
+/*
+ *  Internal header file for Samsung SSDTV serial ports (UART0, 1)
+ *
+ *  Copyright (C) 2006 Samsung Electronics.
+ *
+ */
+
+#ifndef ASM_ARM_HARDWARE_SERIAL_SSDTV_H
+#define ASM_ARM_HARDWARE_SERIAL_SSDTV_H
+
+/* register offset */
+#define SSDTV_UARTLCON_OFF	(0x00)
+#define SSDTV_UARTCON_OFF	(0x04)
+#define SSDTV_UARTFCON_OFF	(0x08)
+#define SSDTV_UARTMCON_OFF	(0x0C)
+#define SSDTV_UARTTRSTAT_OFF	(0x10)
+#define SSDTV_UARTERSTAT_OFF	(0x14)
+#define SSDTV_UARTFSTAT_OFF	(0x18)
+#define SSDTV_UARTMSTAT_OFF	(0x1C)
+#define SSDTV_UARTTXH0_OFF	(0x20)
+#define SSDTV_UARTRXH0_OFF	(0x24)
+#define SSDTV_UARTBRDIV_OFF	(0x28)
+
+#define SSDTV_UART_GAP		(0x40)
+
+#define SSDTV_UART0_OFF		(0x0)
+#define SSDTV_UART1_OFF		(0x40)
+#define SSDTV_UART2_OFF		(0x80)
+#define SSDTV_UART3_OFF		(0xC0)
+
+#define SSDTV_LCON_CFGMASK	(0x3F)
+
+/* LCON Word length */
+#define SSDTV_LCON_CS5		(0x0)
+#define SSDTV_LCON_CS6		(0x1)
+#define SSDTV_LCON_CS7		(0x2)
+#define SSDTV_LCON_CS8		(0x3)
+
+/* LCON Parity */
+#define SSDTV_LCON_PNONE	(0x0)
+#define SSDTV_LCON_PODD		((0x4) << 3)
+#define SSDTV_LCON_PEVEN	((0x5) << 3)
+
+
+#define SSDTV_UCON_RXIRQMODE		(0x1)
+#define SSDTV_UCON_RXIRQMODE_MASK	(0x3)
+#define SSDTV_UCON_TXIRQMODE		(0x1 << 2)
+#define SSDTV_UCON_TXIRQMODE_MASK	(0x3 << 2)
+#define SSDTV_UCON_SBREAK		(1 << 4)
+#define SSDTV_UCON_RXFIFO_TOI		(1 << 7)
+// [8:9] must be 0's
+#define SSDTV_UCON_CLKSEL		(0<<10)
+#define SSDTV_UCON_RXIE			(1<<12)
+#define SSDTV_UCON_TXIE			(1<<13)
+#define SSDTV_UCON_ERIE			(1<<14)
+
+#define SSDTV_UCON_DEFAULT	(SSDTV_UCON_TXIE \
+				| SSDTV_UCON_RXIE \
+				| SSDTV_UCON_ERIE \
+				| SSDTV_UCON_CLKSEL  \
+				| SSDTV_UCON_TXIRQMODE \
+				| SSDTV_UCON_RXIRQMODE \
+				| SSDTV_UCON_RXFIFO_TOI)
+
+#define SSDTV_UFCON_FIFOMODE	(1 << 0)
+#define SSDTV_UFCON_TXTRIG0	(0 << 6)
+#define SSDTV_UFCON_TXTRIG1	(1 << 6)
+#define SSDTV_UFCON_TXTRIG12	(3 << 6)
+#define SSDTV_UFCON_RXTRIG8	(1 << 4)
+#define SSDTV_UFCON_RXTRIG12	(2 << 4)
+#define SSDTV_UFCON_RXTRIG16	(3 << 4)
+#define SSDTV_UFCON_RXTRIG4	(0 << 4)
+#define SSDTV_UFCON_TXFIFORESET	(1 << 2)
+#define SSDTV_UFCON_RXFIFORESET	(1 << 1)
+
+#define SSDTV_UFCON_DEFAULT	(SSDTV_UFCON_FIFOMODE | \
+				SSDTV_UFCON_TXTRIG0 | \
+				SSDTV_UFCON_RXTRIG4 | \
+				SSDTV_UFCON_TXFIFORESET | \
+				SSDTV_UFCON_RXFIFORESET)
+
+#define SSDTV_UTRSTAT_CLEAR	(0xF0)
+#define SSDTV_UTRSTAT_MI	(1 << 7)
+#define SSDTV_UTRSTAT_EI	(1 << 6)
+#define SSDTV_UTRSTAT_TXI	(1 << 5)
+#define SSDTV_UTRSTAT_RXI	(1 << 4)
+#define SSDTV_UTRSTAT_TXE	(1 << 2)
+#define SSDTV_UTRSTAT_TXFE	(1 << 1)
+#define SSDTV_UTRSTAT_RXDR	(1 << 0)
+
+#define SSDTV_UERSTAT_OE	(1 << 0)
+
+
+#endif /* ASM_ARM_HARDWARE_SERIAL_SSDTV_H */
+
diff -urNP old/drivers/usb/host/ehci-hcd.c new/drivers/usb/host/ehci-hcd.c
--- old/drivers/usb/host/ehci-hcd.c	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/usb/host/ehci-hcd.c	2010-07-18 09:57:32.000000000 +0200
@@ -109,7 +109,7 @@
 #define	EHCI_TUNE_RL_TT		0
 #define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
 #define	EHCI_TUNE_MULT_TT	1
-#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+#define	EHCI_TUNE_FLS		0	/* 1024 frame schedule */
 
 #define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
@@ -887,7 +887,7 @@
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
+#if defined(CONFIG_PCI) && !defined(CONFIG_ARCH_SSDTV)
 #include "ehci-pci.c"
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
@@ -902,6 +902,11 @@
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#ifdef CONFIG_ARCH_SSDTV
+#include "ehci-ssdtv.c"
+#define	PLATFORM_DRIVER		ehci_ssdtv_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
diff -urNP old/drivers/usb/host/ehci-ssdtv.c new/drivers/usb/host/ehci-ssdtv.c
--- old/drivers/usb/host/ehci-ssdtv.c	1970-01-01 01:00:00.000000000 +0100
+++ new/drivers/usb/host/ehci-ssdtv.c	2010-07-18 11:01:56.000000000 +0200
@@ -0,0 +1,222 @@
+/*
+ * EHCI HCD Bus glue logic for SSDTV USB Controller
+ *
+ * Modification history
+ * --------------------
+ * 29.July.2009 ij.jang : Port to kernel 2.6.24, rename platform name to ssdtv
+ * 18.July.2007 ij.jang : Port to kernel 2.6.18
+ * 08.Nov.2005 ij.jang : Add initial support for s5h2150
+ * 20.Oct.2006 ij.jang : Created for s5h2110
+ */
+
+#include <linux/platform_device.h>
+
+#if !defined(CONFIG_ARCH_SSDTV)
+#error "This file is only for the SSDTV based platform. Configuration may be wrong."
+#endif
+
+/* called during ssdtv_ehci_hcd_probe() after chip reset completes */
+static int ssdtv_ehci_setup (struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	ehci_dbg (ehci, "SSDTV ehci setup()\n");
+
+	/* EHCI register address */
+	ehci = hcd_to_ehci (hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs +
+		HC_LENGTH (readl(&ehci->caps->hc_capbase));
+
+	dbg_hcs_params (ehci, "reset");
+	dbg_hcc_params (ehci, "reset");
+	
+	/* cache this readonly data (capability) */
+	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+
+	retval = ehci_halt (ehci);
+	if (retval != 0) {
+		ehci_err (ehci, "ehci_halt error\n");
+		return retval;
+	}
+
+	retval = ehci_init (hcd);
+	if (retval != 0) {
+		ehci_err (ehci, "ehci_init error\n");
+		return retval;
+	}
+
+	ehci->sbrn = 0x20;
+	ehci_info (ehci, "ssdtv_ehci_setup success\n");
+
+	return 0;
+}
+
+static int ssdtv_ehci_hcd_probe(struct hc_driver *driver,
+			struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	unsigned long mem_start=0, mem_len=0;
+	int irq;
+	int retval;
+	void *reg_addr = NULL;
+
+	dev_info (&pdev->dev, "initializing SSDTV-SOC USB Controller\n");
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			pdev->dev.bus_id);
+		retval = -ENODEV;
+		goto err0;
+	}
+	irq = res->start;
+	dev_dbg (&pdev->dev, "Found IRQ resource=%d\n", irq);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			pdev->dev.bus_id);
+		retval = -ENODEV;
+		goto err0;
+	}
+	
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				driver->description)) {
+		dev_err(&pdev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto err0;
+	}
+
+	dev_dbg (&pdev->dev, "Found Memory resource: %08X--%08X\n",
+			(unsigned int)res->start,
+			(unsigned int)res->end);
+
+	mem_start = res->start;
+	mem_len = res->end - res->start + 1;
+	reg_addr = ioremap_nocache (mem_start, mem_len);
+	
+	if (reg_addr == NULL) {
+		dev_err(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err1;
+	}
+
+	dev_dbg (&pdev->dev, "SSDTV_EHCI ioremapped : %08X\n",
+			(unsigned int)reg_addr);
+
+	hcd = usb_create_hcd (driver, &pdev->dev, pdev->dev.bus_id);
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	hcd->regs = reg_addr;
+	hcd->rsrc_start = mem_start;
+	hcd->rsrc_len = mem_len;
+
+	retval = usb_add_hcd (hcd, irq, IRQF_DISABLED);
+	
+	if (retval !=0) {
+		usb_put_hcd (hcd);
+	} else {
+		dev_info (&pdev->dev, "ehci-ssdtv probing completed.\n");
+		return 0;
+	}
+
+err2:
+	iounmap (reg_addr);
+err1:
+	release_mem_region(mem_start, mem_len);
+err0:
+	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
+	return retval;
+}
+
+static void ssdtv_ehci_hcd_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	dev_dbg (&pdev->dev, "remove (bus=%s, state=%x)\n",
+			hcd->self.bus_name, hcd->state);
+
+	usb_remove_hcd (hcd);
+	iounmap (hcd->regs);
+	release_mem_region (hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd (hcd);
+}
+
+static struct hc_driver ssdtv_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "SSDTV On-chip EHCI Host controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ssdtv_ehci_setup,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+
+	.suspend		= ehci_bus_suspend,
+	.resume			= ehci_bus_resume,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+};
+
+static int ssdtv_ehci_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return ssdtv_ehci_hcd_probe(&ssdtv_ehci_hc_driver, pdev);
+}
+
+static int ssdtv_ehci_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "ssdtv_ehci_drv_remove\n");
+	ssdtv_ehci_hcd_remove(hcd, pdev);
+
+	return 0;
+}
+
+MODULE_ALIAS("ehci-ssdtv");
+
+static struct platform_driver ehci_ssdtv_driver = {
+	.probe		= ssdtv_ehci_drv_probe,
+	.remove		= ssdtv_ehci_drv_remove,
+	.driver 	= {
+		.name = "ehci-ssdtv",
+		.bus = &platform_bus_type,
+	}
+};
diff -urNP old/drivers/usb/host/ohci-hcd.c new/drivers/usb/host/ohci-hcd.c
--- old/drivers/usb/host/ohci-hcd.c	2007-02-24 00:52:30.000000000 +0100
+++ new/drivers/usb/host/ohci-hcd.c	2010-07-18 09:58:16.000000000 +0200
@@ -877,7 +877,7 @@
 MODULE_DESCRIPTION (DRIVER_INFO);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
+#if defined(CONFIG_PCI) && !defined(CONFIG_MACH_SSDTV)
 #include "ohci-pci.c"
 #endif
 
@@ -917,6 +917,10 @@
 #include "ohci-at91.c"
 #endif
 
+#if defined(CONFIG_ARCH_SSDTV)
+#include "ohci-ssdtv.c"
+#endif
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_S3C2410) \
@@ -928,6 +932,7 @@
       || defined (CONFIG_USB_OHCI_HCD_PPC_SOC) \
       || defined (CONFIG_ARCH_AT91RM9200) \
       || defined (CONFIG_ARCH_AT91SAM9261) \
+      || defined (CONFIG_ARCH_SSDTV) \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -urNP old/drivers/usb/host/ohci-ssdtv.c new/drivers/usb/host/ohci-ssdtv.c
--- old/drivers/usb/host/ohci-ssdtv.c	1970-01-01 01:00:00.000000000 +0100
+++ new/drivers/usb/host/ohci-ssdtv.c	2010-07-18 11:08:51.000000000 +0200
@@ -0,0 +1,205 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * 
+ * SA1111 Bus Glue
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Rusell King et al.
+ *
+ * This file is licenced under the GPL.
+ *
+ * Modification history
+ * --------------------
+ * 29.July.2009 ij.jang : Port to kernel 2.6.24 rename platform name
+ * 18.July.2007 ij.jang : Port to kernel 2.6.18
+ * 08.Nov.2006 ij.jang : add inittial support for s5h2x
+ * 10.Oct.2006 ij.jang : create for s5h2x
+ */
+ 
+#include <linux/platform_device.h>
+
+#if! defined(CONFIG_ARCH_SSDTV)
+#error "This file is only for the SSDTV based platform. Configuration may wrong."
+#endif
+
+#ifdef DEBUG
+#define ssdtv_dbg	printk
+#else
+#define ssdtv_dbg(...)
+#endif
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+void ssdtv_ohci_hcd_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd (hcd);
+	iounmap (hcd->regs);
+	release_mem_region (hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd (hcd);
+}
+
+int ssdtv_ohci_hcd_probe(const struct hc_driver *driver,
+				struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq, retval;
+	unsigned long mem_start, mem_len;
+	void *reg_addr = NULL;
+
+	/* find IRQ number */
+	res = platform_get_resource (pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err (&pdev->dev, "Found HCD with no IRQ, Check %s setup!\n",
+				pdev->dev.bus_id);
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	res = platform_get_resource (pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err (&pdev->dev, "Found HC with no register addr. Check %s setup!\n",
+				pdev->dev.bus_id);
+		return -ENODEV;
+	}
+		
+	mem_start = res->start;
+	mem_len = res->end - res->start + 1;
+	reg_addr = ioremap_nocache (mem_start, mem_len);
+	
+	if (reg_addr == NULL) {
+		dev_err (&pdev->dev, "error mapping memory\n");
+		return -EFAULT;
+	}
+
+	dev_dbg (&pdev->dev, "SSDTV_OHCI ioremapped : %08X\n",
+			(unsigned int)reg_addr);
+
+	hcd = usb_create_hcd (driver, &pdev->dev, "ohci-ssdtv");
+	if (hcd == NULL) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+	hcd->rsrc_start = mem_start;
+	hcd->rsrc_len = mem_len;
+	hcd->regs = reg_addr;
+
+	ohci_hcd_init (hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd (hcd, irq, IRQF_DISABLED);
+	if (retval != 0) {
+		usb_put_hcd (hcd);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	iounmap (hcd->regs);
+	release_mem_region (hcd->rsrc_start, hcd->rsrc_len);
+	return retval;
+}
+
+static int __devinit ssdtv_ohci_hcd_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+	{
+		err ("failed to ohci_init\n");
+		return ret;
+	}
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+	return 0;
+}
+
+static const struct hc_driver ssdtv_ohci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc		= "SSDTV On-chip OHCI Host controller",
+	.hcd_priv_size		= sizeof (struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ohci_irq,
+	.flags			= HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start			= ssdtv_ohci_hcd_start,
+	.stop			= ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ohci_bus_suspend,
+	.bus_resume		= ohci_bus_resume,
+#endif
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static int ssdtv_ohci_drv_probe(struct platform_device *pdev)
+{
+	return ssdtv_ohci_hcd_probe(&ssdtv_ohci_hc_driver, pdev);
+}
+
+static int ssdtv_ohci_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata (pdev);
+	ssdtv_ohci_hcd_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ssdtv_ohci_driver = {
+	.probe  = ssdtv_ohci_drv_probe,
+	.remove = ssdtv_ohci_drv_remove,
+
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name   = "ohci-ssdtv",
+	},
+};
+
+static int __init ssdtv_ohci_modinit(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+	return platform_driver_register(&ssdtv_ohci_driver);
+}
+
+static void __exit ssdtv_ohci_modexit(void)
+{
+	platform_driver_unregister(&ssdtv_ohci_driver);
+}
+
+module_init (ssdtv_ohci_modinit);
+module_exit (ssdtv_ohci_modexit);
+
diff -urNP old/include/asm-arm/arch-ssdtv/bitfield.h new/include/asm-arm/arch-ssdtv/bitfield.h
--- old/include/asm-arm/arch-ssdtv/bitfield.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/bitfield.h	2010-07-18 12:13:38.000000000 +0200
@@ -0,0 +1,117 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/bitfield.h
+ *
+ */
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+			(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+			((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
diff -urNP old/include/asm-arm/arch-ssdtv/bits.h new/include/asm-arm/arch-ssdtv/bits.h
--- old/include/asm-arm/arch-ssdtv/bits.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/bits.h	2010-07-18 12:13:28.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/bits.h
+ *
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Bit field definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __bits_h
+#define __bits_h                        1
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+#endif
+
diff -urNP old/include/asm-arm/arch-ssdtv/debug-macro.S new/include/asm-arm/arch-ssdtv/debug-macro.S
--- old/include/asm-arm/arch-ssdtv/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/debug-macro.S	2010-07-18 12:16:02.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2003-2006 tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/debug-macro.S
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <asm/arch/platform.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1				@ MMU enabled?
+	moveq	\rx, #PA_UART_BASE & 0xFF000000	@ physical base address
+	movne	\rx, #VA_UART_BASE & 0xFF000000	@ virtual base
+	add	\rx, \rx, #PA_UART_BASE & 0x00FF0000
+	add	\rx, \rx, #PA_UART_BASE & 0x0000FF00
+	add	\rx, \rx, #PA_UART_BASE & 0x000000FF
+	add	\rx, \rx, #0x40			@ UART1 offset
+	.endm
+
+	.macro	senduart,rd,rx
+	str	\rd, [\rx, #0x20]
+	.endm
+
+	.macro waituart,rd,rx
+	1001:
+	ldr	\rd, [\rx, #0x10]
+	ands	\rd, \rd, #4
+	beq	1001b
+	.endm
+
+	.macro	busyuart,rd,rx
+	.endm
diff -urNP old/include/asm-arm/arch-ssdtv/dma.h new/include/asm-arm/arch-ssdtv/dma.h
--- old/include/asm-arm/arch-ssdtv/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/dma.h	2010-07-18 12:12:57.000000000 +0200
@@ -0,0 +1,20 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/dma.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff -urNP old/include/asm-arm/arch-ssdtv/entry-macro.S new/include/asm-arm/arch-ssdtv/entry-macro.S
--- old/include/asm-arm/arch-ssdtv/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/entry-macro.S	2010-07-18 12:15:06.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * Samsung DTV Soc interrupt Assembler
+ * Copyright (C) 2003 - 2006 tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/include/asm-arm/arch-sdp/entry-macro.S
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <asm/hardware.h>
+
+#ifndef VA_INTC_BASE
+#define VA_INTC_BASE VA_INT_BASE
+#endif
+
+.macro  disable_fiq
+.endm
+
+.macro arch_ret_to_user, tmp1, tmp2
+.endm
+
+.macro get_irqnr_preamble, base, tmp
+.endm
+
+/* Try to semi vectored interrupt.
+ * if using semi vectored interrupt, must set semi-vectored
+ * interrupt in INTCON register
+ * tukho.kim@samsung.com 2006, 08 */
+
+.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+	mov	\base, #VA_INTC_BASE&0xff000000 @ IO Base add virtual
+	add	\base, \base, #VA_INTC_BASE&0x00ff0000
+	add	\base, \base, #VA_INTC_BASE&0x0000ff00
+
+	@ read rI_ISPR register check, 
+	@ if Pend regiser is 0, just out
+	ldr	\irqstat, [\base, #0x3c]      @ get interrupts bits
+	cmp	\irqstat, #0
+	moveq	\irqnr, #0
+	ldrne	\irqstat, [\base, #0x78]
+	movne	\irqnr, \irqstat, LSR #0x2
+.endm
+
diff -urNP old/include/asm-arm/arch-ssdtv/gpio.h new/include/asm-arm/arch-ssdtv/gpio.h
--- old/include/asm-arm/arch-ssdtv/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/gpio.h	2010-07-18 12:26:06.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2009 Samsung Electronics
+ *  Ikjoon Jang <ij.jang@samsung.com>
+ *
+ * User level interface to SSDTV GPIO driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/include/asm-arm/arch-sdp/sdp_gpio_board.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+ 
+#ifndef _SDP_GPIO_IO_H_
+#define _SDP_GPIO_IO_H_
+
+#define SSDTV_GPIO_DEVNAME	"ssdtv_gpio"
+
+/* user level command via ioctl */
+#define GPIO_IOC_CONFIG		'J'
+#define GPIO_IOC_WRITE		'K'
+#define GPIO_IOC_READ		'L'
+
+/* user level argument via ioctl */
+struct gpio_ctl_param {
+	unsigned int	port;
+	unsigned int	pin;
+	unsigned int	val;
+
+/* available values for 'val' member */
+/* When ioctl cmd is GPIO_IOC_[READ|WRITE] */
+#define GPIO_LEVEL_MASK		0x001
+#define GPIO_LEVEL_LOW		0x000
+#define GPIO_LEVEL_HIGH		0x001
+	
+/* When ioctl cmd is GPIO_IOC_CONFIG */
+/* control, not same as hw definitions */
+#define GPIO_FUNC_MASK		0x030
+#define GPIO_FUNC_FN		0x010
+#define GPIO_FUNC_IN		0x020
+#define GPIO_FUNC_OUT		0x030
+
+/* pull, not same as hw definitions */
+#define GPIO_PULL_MASK		0x300
+#define GPIO_PULL_OFF		0x100
+#define GPIO_PULL_DN		0x200
+#define GPIO_PULL_UP		0x300
+};
+
+#endif
diff -urNP old/include/asm-arm/arch-ssdtv/gpio_board.h new/include/asm-arm/arch-ssdtv/gpio_board.h
--- old/include/asm-arm/arch-ssdtv/gpio_board.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/gpio_board.h	2010-07-18 12:45:51.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2009 Samsung Electronics
+ *  Ikjoon Jang <ij.jang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/arch/arm/mach-sdp/sdp_gpio.c
+ * Later changes Copyright (C) 2010 SamyGO team
+ */
+
+#ifndef _SSDTV_GPIO_BOARD_H_
+#define _SSDTV_GPIO_BOARD_H_
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+#define SSDTV_GPIO_MAX_PINS	8
+
+enum ssdtv_gpio_pstate {
+	SSDTV_GPIO_PULL_OFF = 0,
+	SSDTV_GPIO_PULL_DN,
+	SSDTV_GPIO_PULL_RESERVED,
+	SSDTV_GPIO_PULL_UP,
+};
+
+struct ssdtv_gpio_pull {
+	u32			reg_offset;	/* offset from GPIO_BASE */
+	u32			reg_shift;
+	enum ssdtv_gpio_pstate	state;		/* saved context */
+};
+
+struct ssdtv_gpio_reg {
+	u32	con;
+	u32	wdat;
+	u32	rdat;
+};
+
+struct ssdtv_gpio_port {
+	u32				portno;
+	u32				npins;
+	u32				reg_offset;	/* offset from GPIO_BASE */
+	
+	spinlock_t			lock_port;
+	struct ssdtv_gpio_reg __iomem	*reg;
+	u32	 			control;	/* saved context */
+	
+	struct ssdtv_gpio_pull		pins[SSDTV_GPIO_MAX_PINS];
+};
+
+int ssdtv_gpio_add_device(u32 addr, size_t reg_len, struct ssdtv_gpio_port *ports, int nports);
+
+#endif
diff -urNP old/include/asm-arm/arch-ssdtv/hardware.h new/include/asm-arm/arch-ssdtv/hardware.h
--- old/include/asm-arm/arch-ssdtv/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/hardware.h	2010-07-18 12:12:38.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-arm/arch-s5h2111/hardware.h
+ *
+ *  This file contains the hardware definitions of Lake SOC
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *  Copyright (C) 2006 Samsung elctronics co.
+ *  Author : seongkoo.cheong@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/hardware.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+
+#define pcibios_assign_all_busses()	1
+#define PCIBIOS_MIN_IO			0x6000
+#define PCIBIOS_MIN_MEM			0x00100000
+
+#endif
+
diff -urNP old/include/asm-arm/arch-ssdtv/io.h new/include/asm-arm/arch-ssdtv/io.h
--- old/include/asm-arm/arch-ssdtv/io.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/io.h	2010-07-18 12:12:28.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-arm/arch-ssdtv/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2006 Samsung elctronics co.
+ *  Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/io.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ * modification history
+ * --------------------
+ * 15,Sep,2006 ij.jang : Add __mem_pci macro
+ * 9 ,Nov,2006 ij.jang : modify __io macro, Add some macro for PCI
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT		0x0FFFFFFF
+#define PCI_IO_VADDR		0xF4000000
+
+#define __io(a)				((void __iomem *)(PCI_IO_VADDR + (a)))
+
+#define iomem_valid_addr(iomem,size)	(1)
+#define iomem_to_phys(iomem)		(iomem)
+
+#define __mem_pci(a)			((void __iomem *)(a))
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff -urNP old/include/asm-arm/arch-ssdtv/irqs.h new/include/asm-arm/arch-ssdtv/irqs.h
--- old/include/asm-arm/arch-ssdtv/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/irqs.h	2010-07-18 12:12:21.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+ * linux/include/asm-arm/arch-ssdtv/irqs.h
+ *
+ * Copyright (C) 2006 SAMSUNG ELECTRONICS  
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/irqs-sdp83.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __SSDTV_IRQS_H
+#define __SSDTV_IRQS_H
+
+/* bits in interrupt register */
+#define BIT_SHIFT_TSD		0
+#define BIT_SHIFT_AIO		1
+#define BIT_SHIFT_AE		2
+#define BIT_SHIFT_MPGE0		3
+#define BIT_SHIFT_MPEG1		4
+#define BIT_SHIFT_DISP		5
+#define BIT_SHIFT_GA2D		6
+#define BIT_SHIFT_GA3D		7
+#define BIT_SHIFT_JPEG		8
+#define BIT_SHIFT_MFD		9
+#define BIT_SHIFT_AVD		10
+#define BIT_SHIFT_CROAD		11
+#define BIT_SHIFT_PCI		12
+#define BIT_SHIFT_DMA		13
+#define BIT_SHIFT_USB_OHCI0	14
+#define BIT_SHIFT_USB_EHCI0	15
+#define BIT_SHIFT_USB_OHCI1	16
+#define BIT_SHIFT_USB_EHCI1	17
+#define BIT_SHIFT_IRB_IRR	18
+#define BIT_SHIFT_UART0		19
+#define BIT_SHIFT_UART1		20
+#define BIT_SHIFT_UART2		21
+#define BIT_SHIFT_SPI		22
+#define BIT_SHIFT_TIMER		23
+#define BIT_SHIFT_I2C		24
+#define BIT_SHIFT_SCI		25
+#define BIT_SHIFT_EXT7		26
+#define BIT_SHIFT_NAND		27
+#define BIT_SHIFT_SE		28
+#define BIT_SHIFT_EXT0		29
+#define BIT_SHIFT_EXT1		30
+#define BIT_SHIFT_SUBINT	31
+
+#define IRQ_TSD			BIT_SHIFT_TSD
+#define IRQ_AIO			BIT_SHIFT_AIO
+#define IRQ_AE			BIT_SHIFT_AE
+#define IRQ_MPGE0		BIT_SHIFT_MPGE0
+#define IRQ_MPEG1		BIT_SHIFT_MPEG1
+#define IRQ_DISP		BIT_SHIFT_DISP
+#define IRQ_GA2D		BIT_SHIFT_GA2D
+#define IRQ_GA3D		BIT_SHIFT_GA3D
+#define IRQ_JPEG		BIT_SHIFT_JPEG
+#define IRQ_MFD			BIT_SHIFT_MFD
+#define IRQ_AVD			BIT_SHIFT_AVD
+#define IRQ_CROAD		BIT_SHIFT_CROAD
+#define IRQ_PCI			BIT_SHIFT_PCI
+#define IRQ_DMA			BIT_SHIFT_DMA
+#define IRQ_USB_OHCI0		BIT_SHIFT_USB_OHCI0
+#define IRQ_USB_EHCI0		BIT_SHIFT_USB_EHCI0
+#define IRQ_USB_OHCI1		BIT_SHIFT_USB_OHCI1
+#define IRQ_USB_EHCI1		BIT_SHIFT_USB_EHCI1
+#define IRQ_IRB_IRR		BIT_SHIFT_IRB_IRR
+#define IRQ_UART0		BIT_SHIFT_UART0
+#define IRQ_UART1		BIT_SHIFT_UART1
+#define IRQ_UART2		BIT_SHIFT_UART2
+#define IRQ_SPI			BIT_SHIFT_SPI
+#define IRQ_TIMER		BIT_SHIFT_TIMER
+#define IRQ_I2C			BIT_SHIFT_I2C
+#define IRQ_SCI			BIT_SHIFT_SCI
+#define IRQ_EXT7		BIT_SHIFT_EXT7
+#define IRQ_NAND		BIT_SHIFT_NAND
+#define IRQ_SE			BIT_SHIFT_SE
+#define IRQ_EXT0		BIT_SHIFT_EXT0
+#define IRQ_EXT1		BIT_SHIFT_EXT1
+#define IRQ_SUBINT		BIT_SHIFT_SUBINT
+
+#define NR_IRQS			(IRQ_SUBINT + 1)
+
+#endif
+
diff -urNP old/include/asm-arm/arch-ssdtv/memory.h new/include/asm-arm/arch-ssdtv/memory.h
--- old/include/asm-arm/arch-ssdtv/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/memory.h	2010-09-01 04:23:06.000000000 +0200
@@ -0,0 +1,101 @@
+/****************************************************************8
+ * linux/include/asm-arm/arch-ssdtv/memory.h
+ * 
+ * Copyright (C) 2007 Samsung Electronics co.
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/memory-leonid64512.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)		__virt_to_phys(x)
+#define __bus_to_virt(x)		__phys_to_virt(x)
+
+#define MACH_MEM0_BASE 			0x60000000	/* West */
+#define MACH_MEM1_BASE 			0x70000000	/* East */
+
+#define PHYS_OFFSET			MACH_MEM0_BASE
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_SSDTV_256MB
+#define MACH_MEM0_SIZE 			SZ_128M
+#define MACH_MEM1_SIZE 			SZ_128M
+#define SYS_MEM0_SIZE			(73 << 20)
+#define SYS_MEM1_SIZE			(39 << 20)
+#define KVADDR_MASK			0x0FFFFFFF
+#else
+#define MACH_MEM0_SIZE 			SZ_256M
+#define MACH_MEM1_SIZE 			SZ_256M
+#define SYS_MEM0_SIZE			(196 << 20)
+#define SYS_MEM1_SIZE			(101 << 20)
+#define KVADDR_MASK			0x1FFFFFFF
+#endif
+
+#define RANGE(value, start, size) 	( ((unsigned long)value >= (unsigned long)start) && \
+						((unsigned long)value < ((unsigned long)start + (size_t)size)) )
+
+/* Bank size limit 256MByte */
+#define MACH_MEM_MASK			0x0FFFFFFF
+#define MACH_MEM_SHIFT			28
+
+/* BANK Membase Mapping*/
+#define __phys_to_virt(x)		(((x >> MACH_MEM_SHIFT) & 1) ? \
+						(PAGE_OFFSET + SYS_MEM0_SIZE + (x & MACH_MEM_MASK) ) : \
+						(PAGE_OFFSET + (x & MACH_MEM_MASK)) )
+
+
+#define __virt_to_phys(x)		(RANGE(x, PAGE_OFFSET, SYS_MEM0_SIZE) ? \
+						(MACH_MEM0_BASE + (x & KVADDR_MASK)) : \
+						(MACH_MEM1_BASE + ((x & KVADDR_MASK) - SYS_MEM0_SIZE)) )
+
+/*
+ * Given a kernel address(virtual address), find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr)		(RANGE(addr, PAGE_OFFSET, SYS_MEM0_SIZE) ? 0 : 1)
+
+/*
+ * Given a page frame number, convert it to a node id.
+ */
+#define PFN_TO_NID(pfn)			(((pfn) >> (MACH_MEM_SHIFT - PAGE_SHIFT)) & 1)
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr)		NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+
+/* BANK Membase Mapping*/
+#define LOCAL_MAP_PFN_NR(addr)		( (((unsigned long)addr & MACH_MEM_MASK) >> PAGE_SHIFT)  )
+
+#define LOCAL_MAP_KVADDR_NR(addr)	( (((unsigned long)addr & KVADDR_MASK) < SYS_MEM0_SIZE) ? \
+                (((unsigned long)addr & KVADDR_MASK) >> PAGE_SHIFT) : \
+                ((((unsigned long)addr & KVADDR_MASK) - SYS_MEM0_SIZE) >> PAGE_SHIFT)  )
+
+#endif // __ASSEMBLY__
+
+#endif /*__ASM_ARCH_MEMORY_H*/
diff -urNP old/include/asm-arm/arch-ssdtv/param.h new/include/asm-arm/arch-ssdtv/param.h
--- old/include/asm-arm/arch-ssdtv/param.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/param.h	2010-07-18 12:11:42.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-arm/arch-ssdtv/param.h
+ *
+ *  This file contains the hardware definitions of Lake SOC
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *  Copyright (C) 2006 Samsung elctronics co.
+ *  Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/param.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_PRAAM_H
+#define __ASM_ARCH_PRAAM_H
+
+#ifndef HZ
+#define HZ	100
+#error "Define HZ"
+#endif
+
+#endif
diff -urNP old/include/asm-arm/arch-ssdtv/platform.h new/include/asm-arm/arch-ssdtv/platform.h
--- old/include/asm-arm/arch-ssdtv/platform.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/platform.h	2010-07-18 12:11:34.000000000 +0200
@@ -0,0 +1,133 @@
+/*
+ *  Copyright (C) 2003-2006 Samsung Electronics
+ *  Author: tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/sdp83.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __SSDTV_PLATFORM_H
+#define __SSDTV_PLATFORM_H
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/ssdtv.h>
+
+/* clock parameters, see clocks.h */
+#define INPUT_FREQ			27000000
+#define FIN				INPUT_FREQ
+
+#define FCLK				600000000 
+#define DCLK				400000000 
+#define BCLK				280000000
+#define HCLK				(BCLK >> 1)
+#define PCLK				(BCLK >> 1)  
+
+/* system timer tick or high-resolution timer */
+#define SYS_TICK				HZ
+
+#define SYS_TIMER				0
+
+#define SYS_TIMER_BIT				(1 << SYS_TIMER)
+#define SYS_TIMER_IRQ				(IRQ_TIMER)
+#define ARCH_TIMER_IRQ				(IRQ_TIMER)
+
+#define R_SYSTMCON				VA_TIMER(SYS_TIMER, 0x00)
+#define R_SYSTMDATA				VA_TIMER(SYS_TIMER, 0x04)
+#define R_SYSTMCNT				VA_TIMER(SYS_TIMER, 0x08)
+
+// don't use this define when using hrtimer 
+// 140Mhz -> 140,000,000
+// 100Hz tick -> 1,400,000 * 100
+// 1/4 timer -> 350,000
+// 4 * 5 * 7 * 2500
+#define SYS_TIMER_PRESCALER	 		6
+
+// 20080523 HRTimer (clock source) define
+#if defined(CONFIG_GENERIC_TIME) || defined(CONFIG_GERNERIC_COCKEVENTS)
+#define SSDTV_TIMER_TICK			500000	// 500khz
+#define CLKSRC_TIMER				2
+
+#define CLKSRC_TIMER_BIT			(1 << CLKSRC_TIMER)
+
+#define R_CLKSRCTMCON				VA_TIMER(CLKSRC_TIMER, 0x00)
+#define R_CLKSRCTMDATA				VA_TIMER(CLKSRC_TIMER, 0x04)
+#define R_CLKSRCTMCNT				VA_TIMER(CLKSRC_TIMER, 0x08)
+#endif
+// 20080523 HRTimer (clock source) define end
+/* system timer tick or high-resolution timer end */ 
+
+/* Memory Define */
+/* Move to include/asm-arm/arch-ssdtv/memory.h */
+#include <asm/arch/memory.h>
+
+/* System Kernel memory size */
+#define KERNEL_MEM_SIZE			(SYS_MEM0_SIZE + SYS_MEM1_SIZE)
+
+/* flash chip locations(SMC banks) */
+#define PA_FLASH_BANK0			(0x0)
+#define PA_FLASH_BANK1			(0x04000000)
+#define FLASH_MAXSIZE			(32 << 20)
+
+// UART definition 
+#define SSDTV_UART_NR			(3)
+
+#define SER_BAUD_9600			(9600)
+#define SER_BAUD_19200			(19200)
+#define SER_BAUD_38400			(38400)
+#define SER_BAUD_57600			(57600)
+#define SER_BAUD_115200			(115200)
+#define CURRENT_BAUD_RATE		(SER_BAUD_115200)
+
+#define UART_CLOCK			(REQ_PCLK)
+#define SSDTV_GET_UARTCLK(x)		ssdtv_get_clock(x)
+
+// timer definition 
+#define TIMER_CLOCK			(REQ_PCLK)
+#define SSDTV_GET_TIMERCLK(x)		ssdtv_get_clock(x)
+
+// define interrupt resource definition 
+#define SSDTV_INTERRUPT_RESOURCE \
+/*irtSrc, qSrc,           level,       polarity,    priority,   sub priority        */ \
+{{0,    IRQ_TSD,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFFF, 0xFFFFFFFF}, \
+ {1,    IRQ_AIO,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFFE, 0xFFFFFFFF}, \
+ {2,    IRQ_AE,       	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFFC, 0xFFFFFFFF}, \
+ {3,    IRQ_MPGE0,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFF8, 0xFFFFFFFF}, \
+ {4,    IRQ_MPEG1,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFF0, 0xFFFFFFFF}, \
+ {5,    IRQ_DISP,     	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFE0, 0xFFFFFFFF}, \
+ {6,    IRQ_GA2D,     	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFFC0, 0xFFFFFFFF}, \
+ {7,    IRQ_GA3D,     	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFF80, 0xFFFFFFFF}, \
+ {8,    IRQ_JPEG,     	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFF00, 0xFFFFFFFF}, \
+ {9,    IRQ_MFD,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFE00, 0xFFFFFFFF}, \
+ {10,   IRQ_AVD,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFFC00, 0xFFFFFFFF}, \
+ {11,   IRQ_CROAD,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFF800, 0xFFFFFFFF}, \
+ {12,   IRQ_PCI,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFF000, 0xFFFFFFFF}, \
+ {13,   IRQ_DMA,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFE000, 0xFFFFFFFF}, \
+ {14,   IRQ_USB_OHCI0,	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFFC000, 0xFFFFFFFF}, \
+ {15,   IRQ_USB_EHCI0,	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFF8000, 0xFFFFFFFF}, \
+ {16,   IRQ_USB_OHCI1,	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFF0000, 0xFFFFFFFF}, \
+ {17,   IRQ_USB_EHCI1,	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFE0000, 0xFFFFFFFF}, \
+ {18,   IRQ_IRB_IRR,  	LEVEL_LEVEL, POLARITY_HIGH, 0xFFFC0000, 0xFFFFFFFF}, \
+ {19,   IRQ_UART0,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFF80000, 0xFFFFFFFF}, \
+ {20,   IRQ_UART1,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFF00000, 0xFFFFFFFF}, \
+ {21,   IRQ_UART2,    	LEVEL_LEVEL, POLARITY_HIGH, 0xFFE00000, 0xFFFFFFFF}, \
+ {22,   IRQ_SPI,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFFC00000, 0xFFFFFFFF}, \
+ {23,   IRQ_TIMER,    	LEVEL_EDGE,  POLARITY_HIGH, 0xFF800000, 0xFFFFFFFF}, \
+ {24,   IRQ_I2C,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFF000000, 0xFFFFFFFF}, \
+ {25,   IRQ_SCI,      	LEVEL_LEVEL, POLARITY_HIGH, 0xFE000000, 0xFFFFFFFF}, \
+ {26,   IRQ_EXT7,     	LEVEL_EDGE,  POLARITY_HIGH, 0xFC000000, 0xFFFFFFFF}, \
+ {27,   IRQ_NAND,     	LEVEL_LEVEL, POLARITY_HIGH, 0xF8000000, 0xFFFFFFFF}, \
+ {28,   IRQ_SE,       	LEVEL_LEVEL, POLARITY_HIGH, 0xF0000000, 0xFFFFFFFF}, \
+ {29,   IRQ_EXT0,     	LEVEL_EDGE,  POLARITY_HIGH, 0xE0000000, 0xFFFFFFFF}, \
+ {30,   IRQ_EXT1,     	LEVEL_EDGE,  POLARITY_HIGH, 0xC0000000, 0xFFFFFFFF}, \
+ {31,   IRQ_SUBINT,   	LEVEL_LEVEL, POLARITY_HIGH, 0x80000000, 0xFFFFFFFF}, \
+}
+
+#endif
diff -urNP old/include/asm-arm/arch-ssdtv/preempt.h new/include/asm-arm/arch-ssdtv/preempt.h
--- old/include/asm-arm/arch-ssdtv/preempt.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/preempt.h	2010-07-18 12:11:07.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * asm-arm/arch-s5h2111/preempt.h
+ *
+ * Copyright (C) 2004 ARM Limited
+ * Copyright (C) 2006 Samsung Electronics co.
+ * Author : tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/preempt.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef _ASM_ARCH_PREEMT_H
+#define _ASM_ARCH_PREEMT_H
+
+static inline unsigned long clock_diff(unsigned long start, unsigned long stop)
+{
+	return (start - stop);
+}
+
+extern unsigned long ssdtv_timer_read(void);
+
+/*
+ * timer 1 runs @ 1Mhz, 1 tick = 1 microsecond
+ * and is configured as a count down timer.
+ */
+
+#define TICKS_PER_USEC			2
+#define ARCH_PREDEFINES_TICKS_PER_USEC
+#define readclock()		(ssdtv_timer_read())
+#define clock_to_usecs(x)	((x) * TICKS_PER_USEC)
+#define INTERRUPTS_ENABLED(x)	(!(x & PSR_I_BIT))
+
+#endif
+
diff -urNP old/include/asm-arm/arch-ssdtv/proc-macros.S new/include/asm-arm/arch-ssdtv/proc-macros.S
--- old/include/asm-arm/arch-ssdtv/proc-macros.S	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/proc-macros.S	2010-07-18 12:08:22.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2006 Samsung Electronics co.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/proc-macros.S
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#include <asm/hardware.h>
+
+#ifndef VA_INTC_BASE
+#define VA_INTC_BASE VA_INT_BASE
+#endif
+
+	.macro	wait_for_interrupt, addr, val
+	mov	\addr, #VA_INTC_BASE&0xff000000
+	add	\addr, \addr, #VA_INTC_BASE&0x00ff0000
+	add	\addr, \addr, #VA_INTC_BASE&0x0000ff00
+1:
+	ldr	\val, [\addr, #0x3c]
+	cmp	\val, #0
+	beq	1b
+	.endm
+
diff -urNP old/include/asm-arm/arch-ssdtv/ssdtv.h new/include/asm-arm/arch-ssdtv/ssdtv.h
--- old/include/asm-arm/arch-ssdtv/ssdtv.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/ssdtv.h	2010-07-18 12:10:44.000000000 +0200
@@ -0,0 +1,571 @@
+/*
+ *  Copyright (C) 2003-2008 Samsung Electronics
+ *  Author: tukho.kim@samsung.com - 06.16.2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/include/asm-arm/arch-ssdtv/leonid.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+/* modifications
+ * --------------------
+ *  23.Oct.2008 expand system memory area (~0xe0000000)
+ */
+
+#ifndef __SSDTV_H
+#define __SSDTV_H
+
+#include "bitfield.h"
+
+#define VA_IO_BASE0		(0xF8000000)
+#define PA_IO_BASE0		(0x30000000)
+#define DIFF_IO_BASE0		(VA_IO_BASE0 - PA_IO_BASE0)
+
+/* NAND Memory Controller Register */
+#define PA_NAND_BASE		(0x30020000)
+#define VA_NAND_BASE		(PA_NAND_BASE + DIFF_IO_BASE0)
+
+/* Static Memory Controller Register */
+#define PA_SMC_BASE		(0x30028000)
+#define VA_SMC_BASE		(PA_SMC_BASE + DIFF_IO_BASE0)
+
+/* PCI Host & Target controller register */
+#define PA_PCI_BASE		(0x30030000)
+#define VA_PCI_BASE		(PA_PCI_BASE + DIFF_IO_BASE0)
+
+/* DMA controller register */
+#define PA_DMA_BASE		(0x30040000)
+#define VA_DMA_BASE		(PA_DMA_BASE + DIFF_IO_BASE0)
+
+/* USB EHCI0 host controller register */
+#define PA_EHCI0_BASE		(0x30070000)
+#define VA_EHCI0_BASE		(PA_EHCI0_BASE + DIFF_IO_BASE0)
+
+/* USB OHCI0 host controller register */
+#define PA_OHCI0_BASE		(PA_EHCI0_BASE + 0x8000)
+#define VA_OHCI0_BASE		(PA_OHCI0_BASE + DIFF_IO_BASE0)
+
+/* USB EHCI1 host controller register */
+#define PA_EHCI1_BASE		(0x30080000)
+#define VA_EHCI1_BASE		(PA_EHCI1_BASE + DIFF_IO_BASE0)
+
+/* USB OHCI1 host controller register */
+#define PA_OHCI1_BASE		(PA_EHCI1_BASE + 0x8000)
+#define VA_OHCI1_BASE		(PA_OHCI1_BASE + DIFF_IO_BASE0)
+
+/* Timer Register */
+#define PA_TIMER_BASE		(0x30090400)
+#define VA_TIMER_BASE		(PA_TIMER_BASE + DIFF_IO_BASE0)
+
+/* Watchdog Register */
+#define PA_WDT_BASE		(0x30090600)
+#define VA_WDT_BASE		(PA_WDT_BASE + DIFF_IO_BASE0)
+
+/* Power Management unit & PLL Register */
+#define PA_PMU_BASE		(0x30090800)
+#define VA_PMU_BASE		(PA_PMU_BASE + DIFF_IO_BASE0)
+
+/* UART Register */
+#define PA_UART_BASE		(0x30090A00)
+#define VA_UART_BASE		(PA_UART_BASE + DIFF_IO_BASE0)
+
+/* Pad Control Register */
+#define PA_PADCTRL_BASE		(0x30090C00)
+#define VA_PADCTRL_BASE		(PA_GPIO_BASE + DIFF_IO_BASE0)
+
+/* Interrupt controller register */
+#define PA_INTC_BASE		(0x30090F00)
+#define VA_INTC_BASE		(PA_INTC_BASE + DIFF_IO_BASE0)
+
+/* SMC Register */
+#define VA_SMC(offset)  (*(volatile unsigned *)(VA_SMC_BASE + (offset)))
+
+#define O_SMC_BANK0		(0x48)
+#define O_SMC_BANK1		(0x24)
+#define O_SMC_BANK2		(0x00)
+#define O_SMC_BANK3		(0x6C)
+
+#define VA_SMC_BANK(bank, offset)  (*(volatile unsigned *)(VA_SMC_BASE+(bank) + (offset)))
+#define VA_SMC_BANK0(offset)	VA_SMC_BANK(O_SMC_BANK0, offset)
+#define VA_SMC_BANK1(offset)	VA_SMC_BANK(O_SMC_BANK1, offset)
+#define VA_SMC_BANK2(offset)	VA_SMC_BANK(O_SMC_BANK2, offset)
+#define VA_SMC_BANK3(offset)	VA_SMC_BANK(O_SMC_BANK3, offset)
+
+#define O_SMC_SMBIDCYR			(0x00)
+#define O_SMC_SMBWST1R			(0x04)
+#define O_SMC_SMBWST2R			(0x08)
+#define O_SMC_SMBWSTOENR		(0x0C)
+#define O_SMC_SMBWSTWENR		(0x10)
+#define O_SMC_SMBCR			(0x14)
+#define O_SMC_SMBSR			(0x18)
+#define O_SMC_CIWRCON			(0x1C)
+#define O_SMC_CIRDCON			(0x20)
+
+#define O_SMC_SMBEWS			(0x120)
+#define O_SMC_CI_RESET			(0x128)
+#define O_SMC_CI_ADDRSEL		(0x12C)
+#define O_SMC_CI_CNTL			(0x130)
+#define O_SMC_CI_REGADDR		(0x134)
+
+#define O_SMC_CLKSTOP			(0x1E8)
+#define O_SMC_SYNCEN			(0x1EC)
+#define O_SMC_SMBWST3R_BK0		(0x140)
+#define O_SMC_SMBWST3R_BK1		(0x144)
+#define O_SMC_SMBWST3R_BK2		(0x148)
+#define O_SMC_SMBWST3R_BK3		(0x14C)
+
+#define O_SMC_PERIPHID0			(0xFE0)
+#define O_SMC_PERIPHID1			(0xFE4)
+#define O_SMC_PERIPHID2			(0xFE8)
+#define O_SMC_PERIPHID3			(0xFEC)
+#define O_SMC_PCELLID0			(0xFF0)
+#define O_SMC_PCELLID1			(0xFF4)
+#define O_SMC_PCELLID2			(0xFF8)
+#define O_SMC_PCELLID3			(0xFFC)
+
+#define R_SMC_SMBEWS			VA_SMC(O_SMC_SMBEWS)
+#define R_SMC_CI_RESET			VA_SMC(O_SMC_CI_RESET)
+#define R_SMC_CI_ADDRSEL		VA_SMC(O_SMC_CI_ADDRSEL)
+#define R_SMC_CI_CNTL			VA_SMC(O_SMC_CI_CNTL)
+#define R_SMC_CI_REGADDR		VA_SMC(O_SMC_CI_REGADDR)
+
+#define R_SMC_CLKSTOP			VA_SMC(O_SMC_CLKSTOP)
+#define R_SMC_SYNCEN			VA_SMC(O_SMC_SYNCEN)
+
+#define R_SMC_PERIPHID0			VA_SMC(O_SMC_PERIPHID0)
+#define R_SMC_PERIPHID1			VA_SMC(O_SMC_PERIPHID1)
+#define R_SMC_PERIPHID2			VA_SMC(O_SMC_PERIPHID2)
+#define R_SMC_PERIPHID3			VA_SMC(O_SMC_PERIPHID3)
+#define R_SMC_PCELLID0			VA_SMC(O_SMC_PCELLID0)
+#define R_SMC_PCELLID1			VA_SMC(O_SMC_PCELLID1)
+#define R_SMC_PCELLID2			VA_SMC(O_SMC_PCELLID2)
+#define R_SMC_PCELLID3			VA_SMC(O_SMC_PCELLID3)
+
+#define R_SMC_SMBIDCYR_BK0		VA_SMC_BANK0(O_SMC_SMBIDCYR)
+#define R_SMC_SMBWST1R_BK0		VA_SMC_BANK0(O_SMC_SMBWST1R)
+#define R_SMC_SMBWST2R_BK0		VA_SMC_BANK0(O_SMC_SMBWST2R)
+#define R_SMC_SMBWSTOENR_BK0		VA_SMC_BANK0(O_SMC_SMBWSTOENR)
+#define R_SMC_SMBWSTWENR_BK0		VA_SMC_BANK0(O_SMC_SMBWSTWENR)
+#define R_SMC_SMBCR_BK0			VA_SMC_BANK0(O_SMC_SMBCR)
+#define R_SMC_SMBSR_BK0			VA_SMC_BANK0(O_SMC_SMBSR)
+#define R_SMC_CIWRCON_BK0		VA_SMC_BANK0(O_SMC_CIWRCON)
+#define R_SMC_CIRDCON_BK0		VA_SMC_BANK0(O_SMC_CIRDCON)
+#define R_SMC_SMBWST3R_BK0		VA_SMC(O_SMC_SMBSWST3R_BK0)
+
+#define R_SMC_SMBIDCYR_BK1		VA_SMC_BANK1(O_SMC_SMBIDCYR)
+#define R_SMC_SMBWST1R_BK1		VA_SMC_BANK1(O_SMC_SMBWST1R)
+#define R_SMC_SMBWST2R_BK1		VA_SMC_BANK1(O_SMC_SMBWST2R)
+#define R_SMC_SMBWSTOENR_BK1		VA_SMC_BANK1(O_SMC_SMBWSTOENR)
+#define R_SMC_SMBWSTWENR_BK1		VA_SMC_BANK1(O_SMC_SMBWSTWENR)
+#define R_SMC_SMBCR_BK1			VA_SMC_BANK1(O_SMC_SMBCR)
+#define R_SMC_SMBSR_BK1			VA_SMC_BANK1(O_SMC_SMBSR)
+#define R_SMC_CIWRCON_BK1		VA_SMC_BANK1(O_SMC_CIWRCON)
+#define R_SMC_CIRDCON_BK1		VA_SMC_BANK1(O_SMC_CIRDCON)
+#define R_SMC_SMBWST3R_BK1		VA_SMC(O_SMC_SMBSWST3R_BK1)
+
+#define R_SMC_SMBIDCYR_BK2		VA_SMC_BANK2(O_SMC_SMBIDCYR)
+#define R_SMC_SMBWST1R_BK2		VA_SMC_BANK2(O_SMC_SMBWST1R)
+#define R_SMC_SMBWST2R_BK2		VA_SMC_BANK2(O_SMC_SMBWST2R)
+#define R_SMC_SMBWSTOENR_BK2		VA_SMC_BANK2(O_SMC_SMBWSTOENR)
+#define R_SMC_SMBWSTWENR_BK2		VA_SMC_BANK2(O_SMC_SMBWSTWENR)
+#define R_SMC_SMBCR_BK2			VA_SMC_BANK2(O_SMC_SMBCR)
+#define R_SMC_SMBSR_BK2			VA_SMC_BANK2(O_SMC_SMBSR)
+#define R_SMC_CIWRCON_BK2		VA_SMC_BANK2(O_SMC_CIWRCON)
+#define R_SMC_CIRDCON_BK2		VA_SMC_BANK2(O_SMC_CIRDCON)
+#define R_SMC_SMBWST3R_BK2		VA_SMC(O_SMC_SMBSWST3R_BK2)
+
+#define R_SMC_SMBIDCYR_BK3		VA_SMC_BANK3(O_SMC_SMBIDCYR)
+#define R_SMC_SMBWST1R_BK3		VA_SMC_BANK3(O_SMC_SMBWST1R)
+#define R_SMC_SMBWST2R_BK3		VA_SMC_BANK3(O_SMC_SMBWST2R)
+#define R_SMC_SMBWSTOENR_BK3		VA_SMC_BANK3(O_SMC_SMBWSTOENR)
+#define R_SMC_SMBWSTWENR_BK3		VA_SMC_BANK3(O_SMC_SMBWSTWENR)
+#define R_SMC_SMBCR_BK3			VA_SMC_BANK3(O_SMC_SMBCR)
+#define R_SMC_SMBSR_BK3			VA_SMC_BANK3(O_SMC_SMBSR)
+#define R_SMC_CIWRCON_BK3		VA_SMC_BANK3(O_SMC_CIWRCON)
+#define R_SMC_CIRDCON_BK3		VA_SMC_BANK3(O_SMC_CIRDCON)
+#define R_SMC_SMBWST3R_BK3		VA_SMC(O_SMC_SMBSWST3R_BK3)
+
+
+/* interrupt controller */
+#define VA_INTC(offset)  (*(volatile unsigned *)(VA_INTC_BASE + (offset)))
+
+#define O_INTCON		(0x00)		/* R/W */
+#define O_INTPND		(0x04)
+#define O_INTMOD		(0x08)
+#define O_INTMSK		(0x0C)
+#define O_LEVEL			(0x10)
+#define O_I_PSLV0		(0x14)
+#define O_I_PSLV1		(0x18)
+#define O_I_PSLV2		(0x1C)
+#define O_I_PSLV3		(0x20)
+#define O_I_PMST		(0x24)
+#define O_I_CSLV0		(0x28)
+#define O_I_CSLV1		(0x2C)
+#define O_I_CSLV2		(0x30)
+#define O_I_CSLV3		(0x34)
+#define O_I_CMST		(0x38)
+#define O_I_ISPR		(0x3C)
+#define O_I_ISPC		(0x40)
+#define O_F_PSLV0		(0x44)
+#define O_F_PSLV1		(0x48)
+#define O_F_PSLV2		(0x4C)
+#define O_F_PSLV3		(0x50)
+#define O_F_PMST		(0x54)
+#define O_F_CSLV0		(0x58)
+#define O_F_CSLV1		(0x5C)
+#define O_F_CSLV2		(0x60)
+#define O_F_CSLV3		(0x64)
+#define O_F_CMST		(0x68)
+#define O_F_ISPR		(0x6C)
+#define O_F_ISPC		(0x70)
+#define O_POLARITY		(0x74)
+#define O_I_VECADDR		(0x78)
+#define O_F_VECADDR		(0x7C)
+#define O_TIC_QSRC		(0x80)
+#define O_TIC_FIRQ		(0x84)
+/* reserved			(0x88) */
+#define O_TIC_TESTEN		(0x8C)
+#define O_SRCPND		(0x90)
+#define O_SUBINT		(0x94)
+#define O_INTSRCSEL0		(0x98)
+#define O_INTSRCSEL1		(0x9C)
+#define O_INTSRCSEL2		(0xA0)
+#define O_INTSRCSEL3		(0xA4)
+#define O_INTSRCSEL4		(0xA8)
+#define O_INTSRCSEL5		(0xAC)
+#define O_INTSRCSEL6		(0xB0)
+#define O_INTSRCSEL7		(0xB4)
+
+/* define for 'C' */
+#define R_INTCON		VA_INTC(O_INTCON)
+#define R_INTPND		VA_INTC(O_INTPND)
+#define R_INTMOD		VA_INTC(O_INTMOD)
+#define R_INTMSK		VA_INTC(O_INTMSK)
+#define R_LEVEL			VA_INTC(O_LEVEL)
+#define R_I_PSLV0		VA_INTC(O_I_PSLV0)
+#define R_I_PSLV1 		VA_INTC(O_I_PSLV1)
+#define R_I_PSLV2		VA_INTC(O_I_PSLV2)
+#define R_I_PSLV3		VA_INTC(O_I_PSLV3)
+#define R_I_PMST		VA_INTC(O_I_PMST)
+#define R_I_CSLV0		VA_INTC(O_I_CSLV0)
+#define R_I_CSLV1		VA_INTC(O_I_CSLV1)
+#define R_I_CSLV2		VA_INTC(O_I_CSLV2)
+#define R_I_CSLV3		VA_INTC(O_I_CSLV3)
+#define R_I_CMST		VA_INTC(O_I_CMST)
+#define R_I_ISPR		VA_INTC(O_I_ISPR)
+#define R_I_ISPC		VA_INTC(O_I_ISPC)
+#define R_F_PSLV0		VA_INTC(O_F_PSLV0)
+#define R_F_PSLV1		VA_INTC(O_F_PSLV1)
+#define R_F_PSLV2		VA_INTC(O_F_PSLV2)
+#define R_F_PSLV3		VA_INTC(O_F_PSLV3)
+#define R_F_PMST		VA_INTC(O_F_PMST)
+#define R_F_CSLV0		VA_INTC(O_F_CSLV0)
+#define R_F_CSLV1		VA_INTC(O_F_CSLV1)
+#define R_F_CSLV2		VA_INTC(O_F_CSLV2)
+#define R_F_CSLV3 		VA_INTC(O_F_CSLV3)
+#define R_F_CMST		VA_INTC(O_F_CMST)
+#define R_F_ISPR		VA_INTC(O_F_ISPR)
+#define R_F_ISPC		VA_INTC(O_F_ISPC)
+#define R_POLARITY		VA_INTC(O_POLARITY)
+#define R_I_VECADDR		VA_INTC(O_I_VECADDR)
+#define R_F_VECADDR		VA_INTC(O_F_VECADDR)
+#define R_TIC_QSRC		VA_INTC(O_TIC_QSRC)
+#define R_TIC_FIRQ		VA_INTC(O_TIC_FIRQ)
+/* reserved			(0x88) */
+#define R_TIC_TESTEN		VA_INTC(O_TIC_TESTEN)
+#define R_SRCPND		VA_INTC(O_SRCPND)
+#define R_SUBINT		VA_INTC(O_SUBINT)
+#define R_INTSRCSEL0		VA_INTC(O_INTSRCSEL0)
+#define R_INTSRCSEL1		VA_INTC(O_INTSRCSEL1)
+#define R_INTSRCSEL2		VA_INTC(O_INTSRCSEL2)
+#define R_INTSRCSEL3		VA_INTC(O_INTSRCSEL3)
+#define R_INTSRCSEL4		VA_INTC(O_INTSRCSEL4)
+#define R_INTSRCSEL5		VA_INTC(O_INTSRCSEL5)
+#define R_INTSRCSEL6		VA_INTC(O_INTSRCSEL6)
+#define R_INTSRCSEL7		VA_INTC(O_INTSRCSEL7)
+
+/* clock & power management */
+#define VA_PMU(offset)    (*(volatile unsigned *)(VA_PMU_BASE + (offset)))
+
+#define O_PMU_PLL0_PMS_CON		(0x00)
+#define O_PMU_PLL1_PMS_CON		(0x04)
+#define O_PMU_PLL2_PMS_CON		(0x08)
+#define O_PMU_PLL3_PMS_CON		(0x0C)
+#define O_PMU_PLL4_PMS_CON		(0x10)
+#define O_PMU_PLL5_PMS_CON		(0x14)
+#define O_PMU_PLL6_PMS_CON		(0x18)
+/* Reseved 				(0x1C) */
+#define O_PMU_PLL3_K_CON		(0x20)
+#define O_PMU_PLL4_K_CON		(0x24)
+#define O_PMU_PLL5_K_CON		(0x28)
+#define O_PMU_PLL6_CTRL			(0x2C)
+#define O_PMU_PLL0_LOCKCNT		(0x30)
+#define O_PMU_PLL1_LOCKCNT		(0x34)
+#define O_PMU_PLL2_LOCKCNT		(0x38)
+#define O_PMU_PLL3_LOCKCNT		(0x3C)
+#define O_PMU_PLL4_LOCKCNT		(0x40)
+#define O_PMU_PLL5_LOCKCNT		(0x44)
+#define O_PMU_PLL6_LOCKCNT		(0x48)
+/* Reseved 				(0x4C) */
+#define O_PMU_PLL_LOCK			(0x50)
+#define O_PMU_PLL_PWD			(0x54)
+#define O_PMU_PLL_BYPASS		(0x58)
+#define O_PMU_MUX_AS_TEST_SEL		(0x5C)
+#define O_PMU_MUX_SEL0			(0x60)
+#define O_PMU_MUX_SEL1			(0x64)
+#define O_PMU_MUX_SEL2			(0x68)
+#define O_PMU_MUX_SEL3			(0x6C)
+#define O_PMU_MUX_SEL4			(0x70)
+#define O_PMU_MUX_SEL5			(0x74)
+#define O_PMU_MUX_SEL6			(0x78)
+/* Reseved 				(0x7C) */
+#define O_PMU_MASK_CLKS0		(0x80)
+#define O_PMU_MASK_CLKS1		(0x84)
+#define O_PMU_MASK_CLKS2		(0x88)
+#define O_PMU_MASK_CLKS3		(0x8C)
+#define O_PMU_MASK_CLKS4		(0x90)
+#define O_PMU_SW_RESET0			(0x94)
+#define O_PMU_SW_RESET1			(0x98)
+#define O_PMU_AE_SWRST			(0x9C)
+
+/* define for 'C' */
+#define R_PMU_PLL0_PMS_CON		VA_PMU(O_PMU_PLL0_PMS_CON)
+#define R_PMU_PLL1_PMS_CON		VA_PMU(O_PMU_PLL1_PMS_CON)
+#define R_PMU_PLL2_PMS_CON		VA_PMU(O_PMU_PLL2_PMS_CON)
+#define R_PMU_PLL3_PMS_CON		VA_PMU(O_PMU_PLL3_PMS_CON)
+#define R_PMU_PLL4_PMS_CON		VA_PMU(O_PMU_PLL4_PMS_CON)
+#define R_PMU_PLL5_PMS_CON		VA_PMU(O_PMU_PLL5_PMS_CON)
+#define R_PMU_PLL6_PMS_CON		VA_PMU(O_PMU_PLL6_PMS_CON)
+/* Reseved 				VA_PMU( 	) */
+#define R_PMU_PLL3_K_CON		VA_PMU(O_PMU_PLL3_K_CON)
+#define R_PMU_PLL4_K_CON		VA_PMU(O_PMU_PLL4_K_CON)
+#define R_PMU_PLL5_K_CON		VA_PMU(O_PMU_PLL5_K_CON)
+#define R_PMU_PLL6_CTRL			VA_PMU(O_PMU_PLL6_CTRL)
+#define R_PMU_PLL0_LOCKCNT		VA_PMU(O_PMU_PLL0_LOCKCNT)
+#define R_PMU_PLL1_LOCKCNT		VA_PMU(O_PMU_PLL1_LOCKCNT)
+#define R_PMU_PLL2_LOCKCNT		VA_PMU(O_PMU_PLL2_LOCKCNT)
+#define R_PMU_PLL3_LOCKCNT		VA_PMU(O_PMU_PLL3_LOCKCNT)
+#define R_PMU_PLL4_LOCKCNT		VA_PMU(O_PMU_PLL4_LOCKCNT)
+#define R_PMU_PLL5_LOCKCNT		VA_PMU(O_PMU_PLL5_LOCKCNT)
+#define R_PMU_PLL6_LOCKCNT		VA_PMU(O_PMU_PLL6_LOCKCNT)
+/* Reseved 				VA_PMU( 	) */
+#define R_PMU_PLL_LOCK			VA_PMU(O_PMU_PLL_LOCK)
+#define R_PMU_PLL_PWD			VA_PMU(O_PMU_PLL_PWD)
+#define R_PMU_PLL_BYPASS		VA_PMU(O_PMU_PLL_BYPASS)
+#define R_PMU_MUX_AS_TEST_SEL		VA_PMU(O_PMU_MUX_AS_TEST_SEL)
+#define R_PMU_MUX_SEL0			VA_PMU(O_PMU_MUX_SEL0)
+#define R_PMU_MUX_SEL1			VA_PMU(O_PMU_MUX_SEL1)
+#define R_PMU_MUX_SEL2			VA_PMU(O_PMU_MUX_SEL2)
+#define R_PMU_MUX_SEL3			VA_PMU(O_PMU_MUX_SEL3)
+#define R_PMU_MUX_SEL4			VA_PMU(O_PMU_MUX_SEL4)
+#define R_PMU_MUX_SEL5			VA_PMU(O_PMU_MUX_SEL5)
+#define R_PMU_MUX_SEL6			VA_PMU(O_PMU_MUX_SEL6)
+/* Reseved 				VA_PMU( 	) */
+#define R_PMU_MASK_CLKS0		VA_PMU(O_PMU_MASK_CLKS0)
+#define R_PMU_MASK_CLKS1		VA_PMU(O_PMU_MASK_CLKS1)
+#define R_PMU_MASK_CLKS2		VA_PMU(O_PMU_MASK_CLKS2)
+#define R_PMU_MASK_CLKS3		VA_PMU(O_PMU_MASK_CLKS3)
+#define R_PMU_MASK_CLKS4		VA_PMU(O_PMU_MASK_CLKS4)
+#define R_PMU_SW_RESET0			VA_PMU(O_PMU_SW_RESET0)
+#define R_PMU_SW_RESET1			VA_PMU(O_PMU_SW_RESET1)
+#define R_PMU_AE_SWRST			VA_PMU(O_PMU_AE_SWRST)
+
+#define PMU_PLL_P_VALUE(x)	((x >> 20) & 0x3F)
+#define PMU_PLL_M_VALUE(x)	((x >> 8) & 0x3FF)
+#define PMU_PLL_S_VALUE(x)	(x & 7)
+#define PMU_PLL_K_VALUE(x)	(x & 0xFFFF)
+
+#define GET_PLL_M(x)		PMU_PLL_M_VALUE(x)
+#define GET_PLL_P(x)		PMU_PLL_P_VALUE(x)
+#define GET_PLL_S(x)		PMU_PLL_S_VALUE(x)
+
+#define REQ_FCLK	1		/* CPU Clock */
+#define REQ_DCLK	2		/* DDR Clock */
+#define REQ_HCLK	3		/* AHB Clock */
+#define REQ_PCLK	REQ_HCLK	/* APB Clock */
+
+
+
+/* UART */
+/* Don't need register define */
+/* Need Physical Base address */
+#define VA_UART(dt,  n, offset)	\
+	(*(volatile dt *)(VA_UART_BASE + (0x40 * n) + (offset)))
+
+#define VA_UART_0(offset)	VA_UART(unsigned, 0, offset)
+#define VA_UART_1(offset)	VA_UART(unsigned, 1, offset)
+#define VA_UART_2(offset)	VA_UART(unsigned, 2, offset)
+
+#define VA_UART_0_B(offset)	VA_UART(char, 0, offset)
+#define VA_UART_1_B(offset)	VA_UART(char, 1, offset)
+#define VA_UART_2_B(offset)	VA_UART(char, 2, offset)
+
+#define R_ULCON0		VA_UART_0(0x00) /* UART 0 Line control */
+#define R_UCON0			VA_UART_0(0x04) /* UART 0 Control */
+#define R_UFCON0		VA_UART_0(0x08) /* UART 0 FIFO control */
+#define R_UMCON0		VA_UART_0(0x0c) /* UART 0 Modem control */
+#define R_UTRSTAT0		VA_UART_0(0x10) /* UART 0 Tx/Rx status */
+#define R_UERSTAT0		VA_UART_0(0x14) /* UART 0 Rx error status */
+#define R_UFSTAT0		VA_UART_0(0x18) /* UART 0 FIFO status */
+#define R_UMSTAT0		VA_UART_0(0x1c) /* UART 0 Modem status */
+#define R_UBRDIV0		VA_UART_0(0x28) /* UART 0 Baud rate divisor */
+
+#define R_ULCON1		VA_UART_1(0x00) /* UART 1 Line control */
+#define R_UCON1			VA_UART_1(0x04) /* UART 1 Control */
+#define R_UFCON1		VA_UART_1(0x08) /* UART 1 FIFO control */
+#define R_UMCON1		VA_UART_1(0x0c) /* UART 1 Modem control */
+#define R_UTRSTAT1		VA_UART_1(0x10) /* UART 1 Tx/Rx status */
+#define R_UERSTAT1		VA_UART_1(0x14) /* UART 1 Rx error status */
+#define R_UFSTAT1		VA_UART_1(0x18) /* UART 1 FIFO status */
+#define R_UMSTAT1		VA_UART_1(0x1c) /* UART 1 Modem status */
+#define R_UBRDIV1		VA_UART_1(0x28) /* UART 1 Baud rate divisor */
+
+#define R_ULCON2		VA_UART_2(0x00) /* UART 2 Line control */
+#define R_UCON2			VA_UART_2(0x04) /* UART 2 Control */
+#define R_UFCON2		VA_UART_2(0x08) /* UART 2 FIFO control */
+#define R_UMCON2		VA_UART_2(0x0c) /* UART 2 Modem control */
+#define R_UTRSTAT2		VA_UART_2(0x10) /* UART 2 Tx/Rx status */
+#define R_UERSTAT2		VA_UART_2(0x14) /* UART 2 Rx error status */
+#define R_UFSTAT2		VA_UART_2(0x18) /* UART 2 FIFO status */
+#define R_UMSTAT2		VA_UART_2(0x1c) /* UART 2 Modem status */
+#define R_UBRDIV2		VA_UART_2(0x28) /* UART 2 Baud rate divisor */
+
+#ifdef __BIG_ENDIAN
+#define R_UTXH0			VA_UART_0_B(0x23) /* UART 0 Transmission Hold */
+#define R_URXH0			VA_UART_0_B(0x27) /* UART 0 Receive buffer */
+#else /* Little Endian */
+#define R_UTXH0			VA_UART_0_B(0x20) /* UART 0 Transmission Hold */
+#define R_URXH0			VA_UART_0_B(0x24) /* UART 0 Receive buffer */
+#endif
+
+#ifdef __BIG_ENDIAN
+#define R_UTXH1			VA_UART_1_B(0x23) /* UART 1 Transmission Hold */
+#define R_URXH1			VA_UART_1_B(0x27) /* UART 1 Receive buffer */
+#else /* Little Endian */
+#define R_UTXH1			VA_UART_1_B(0x20) /* UART 1 Transmission Hold */
+#define R_URXH1			VA_UART_1_B(0x24) /* UART 1 Receive buffer */
+#endif
+
+#ifdef __BIG_ENDIAN
+#define R_UTXH2			VA_UART_2_B(0x23) /* UART 2 Transmission Hold */
+#define R_URXH2			VA_UART_2_B(0x27) /* UART 2 Receive buffer */
+#else /* Little Endian */
+#define R_UTXH2			VA_UART_2_B(0x20) /* UART 2 Transmission Hold */
+#define R_URXH2			VA_UART_2_B(0x24) /* UART 2 Receive buffer */
+#endif
+
+/* timer */
+#define VA_TIMER(t, offset)	\
+	(*(volatile unsigned *)(VA_TIMER_BASE + (0x10 * t) + (offset)))
+
+#define R_TMDMASEL		VA_TIMER(0, 0x0c) /* dma or interrupt mode selection */
+
+#define VA_TIMER_0(offset)	VA_TIMER(0, offset)
+#define VA_TIMER_1(offset)	VA_TIMER(1, offset)
+#define VA_TIMER_2(offset)	VA_TIMER(2, offset)
+
+#define R_TMCON0		VA_TIMER_0(0x00)
+#define R_TMDATA0		VA_TIMER_0(0x04)
+#define R_TMCNT0		VA_TIMER_0(0x08)
+
+#define R_TMCON1		VA_TIMER_1(0x00)
+#define R_TMDATA1		VA_TIMER_1(0x04)
+#define R_TMCNT1		VA_TIMER_1(0x08)
+
+#define R_TMCON2		VA_TIMER_2(0x00)
+#define R_TMDATA2		VA_TIMER_2(0x04)
+#define R_TMCNT2		VA_TIMER_2(0x08)
+
+#define R_TMSTATUS		VA_TIMER_0(0x30)
+
+#define TMCON_MUX04		(0x0 << 2)
+#define TMCON_MUX08		(0x1 << 2)
+#define TMCON_MUX16		(0x2 << 2)
+#define TMCON_MUX32		(0x3 << 2)
+
+#define TMCON_INT_DMA_EN	(0x1 << 1)
+#define TMCON_RUN		(0x1)
+
+#define TMDATA_PRES(x)	(x > 0) ? ((x & 0xFF) << 16) : 1
+
+
+/* watch dog timer */
+#define VA_WDT(offset)	(*(volatile unsigned *)(VA_WDT_BASE + (offset)))
+
+#define R_WTPSV			VA_WDT(0x00) /* Watch-dog timer prescaler value */
+#define R_WTCON			VA_WDT(0x04) /* Watch-dog timer mode */
+#define R_WTCNT			VA_WDT(0x08) /* Eatch-dog timer count */
+
+/* PAD Controller */
+#define VA_PADCTRL_PORT(offset)  (*(volatile unsigned *)(VA_PADCTRL_BASE + (offset)))
+
+/* PCI */
+#define VA_PCI_CONF(offset)  (*(volatile unsigned *)(VA_PCI_BASE + (offset)))
+#define R_PCIHID		VA_PCI_CONF(0x00)
+#define R_PCIHSC		VA_PCI_CONF(0x04)
+#define R_PCIHCODE		VA_PCI_CONF(0x08)
+#define R_PCIHLINE		VA_PCI_CONF(0x0C)
+#define R_PCIHBAR0		VA_PCI_CONF(0x10)
+#define R_PCIHBAR1		VA_PCI_CONF(0x14)
+#define R_PCIHBAR2		VA_PCI_CONF(0x18)
+/*Reserved */
+#define R_PCIHCISP		VA_PCI_CONF(0x28)
+#define R_PCIHSSID		VA_PCI_CONF(0x2C)
+/*Reserved */
+#define R_PCIHCAP		VA_PCI_CONF(0x34)
+/*Reserved */
+#define R_PCIHLTIT		VA_PCI_CONF(0x3C)
+#define R_PCIHTIMER		VA_PCI_CONF(0x40)
+/*Reserved */
+#define R_PCIHPMR0		VA_PCI_CONF(0xDC)
+#define R_PCIHPMR1		VA_PCI_CONF(0xE0)
+
+#define VA_PCI_BIF(offset)  (*(volatile unsigned *)(VA_PCI_BASE + (offset + 0x100)))
+#define R_PCICON		VA_PCI_BIF(0x00)
+#define R_PCISET		VA_PCI_BIF(0x04)
+#define R_PCIINTEN		VA_PCI_BIF(0x08)
+#define R_PCIINTST		VA_PCI_BIF(0x0C)
+#define R_PCIINTAD		VA_PCI_BIF(0x10)
+#define R_PCIBATAPM		VA_PCI_BIF(0x14)
+#define R_PCIBATAPI		VA_PCI_BIF(0x18)
+#define R_PCIRCC		VA_PCI_BIF(0x1C)
+#define R_PCIDIAG0		VA_PCI_BIF(0x20)
+#define R_PCIDIAG1		VA_PCI_BIF(0x24)
+#define R_PCIBELAP		VA_PCI_BIF(0x28)
+#define R_PCIBELPA		VA_PCI_BIF(0x2C)
+#define R_PCIMAIL0		VA_PCI_BIF(0x30)
+#define R_PCIMAIL1		VA_PCI_BIF(0x34)
+#define R_PCIMAIL2		VA_PCI_BIF(0x38)
+#define R_PCIMAIL3		VA_PCI_BIF(0x3C)
+#define R_PCIBATPA0		VA_PCI_BIF(0x40)
+#define R_PCIBAM0		VA_PCI_BIF(0x44)
+#define R_PCIBATPA1		VA_PCI_BIF(0x48)
+#define R_PCIBAM1		VA_PCI_BIF(0x4C)
+#define R_PCIBATPA2		VA_PCI_BIF(0x50)
+#define R_PCIBAM2		VA_PCI_BIF(0x54)
+#define R_PCISWAP		VA_PCI_BIF(0x58)
+/* Reserved */
+#define R_PCIDMACON0		VA_PCI_BIF(0x80)
+#define R_PCIDMASRC0		VA_PCI_BIF(0x84)
+#define R_PCIDMADST0		VA_PCI_BIF(0x88)
+#define R_PCIDMACNT0		VA_PCI_BIF(0x8C)
+#define R_PCIDMARUN0		VA_PCI_BIF(0x90)
+/* Reserved */
+#define R_PCIDMACON1		VA_PCI_BIF(0xA0)
+#define R_PCIDMASRC1		VA_PCI_BIF(0xA4)
+#define R_PCIDMADST1		VA_PCI_BIF(0xA8)
+#define R_PCIDMACNT1		VA_PCI_BIF(0xAC)
+#define R_PCIDMARUN1		VA_PCI_BIF(0xB0)
+
+
+#ifndef MHZ /* define MHZ */
+#define MHZ		1000000
+#endif
+
+#endif
diff -urNP old/include/asm-arm/arch-ssdtv/system.h new/include/asm-arm/arch-ssdtv/system.h
--- old/include/asm-arm/arch-ssdtv/system.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/system.h	2010-07-18 12:07:22.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2006 Samsung Electronics co.
+ * Author: tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * Content of this file is copied from sources released by Samsung
+ * with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * UE40C8000.zip -> linux.tgz -> linux/include/asm-arm/arch-sdp/system.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt ticks, 
+	 *  using linux library 
+	 */
+#ifndef ARCH_SSDTV
+	cpu_do_idle();
+#else
+	do {
+		if (R_INTPND)
+			break;
+	} while(1);
+#endif
+}
+
+static inline void arch_reset(char mode)
+{
+	/* use the watchdog timer reset to reset the processor */
+
+	/* (at this point, MMU is shut down, so we use physical addrs) */
+	volatile unsigned long *prWTCON = (unsigned long *)(PA_WDT_BASE + 0x00);
+	volatile unsigned long *prWTDAT = (unsigned long *)(PA_WDT_BASE + 0x04);
+	volatile unsigned long *prWTCNT = (unsigned long *)(PA_WDT_BASE + 0x08);
+
+	/* set the countdown timer to a small value before enableing WDT */
+	*prWTDAT = 0x00000100;
+	*prWTCNT = 0x00000100;
+
+	/* enable the watchdog timer */
+	*prWTCON = 0x00008021;
+
+	/* machine should reboot..... */
+	mdelay(5000);
+	panic("Watchdog timer reset failed!\n");
+	printk(" Jump to address 0 \n");
+	cpu_reset(0);
+}
+
+#endif
+
diff -urNP old/include/asm-arm/arch-ssdtv/timex.h new/include/asm-arm/arch-ssdtv/timex.h
--- old/include/asm-arm/arch-ssdtv/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/timex.h	2010-07-18 12:09:18.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/arch-ssdtv/timex.h
+ *
+ *  s5h2111(Lake) architecture timex specifications
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright 2006 Samsung Electronics co
+ *  Author: tukho.kim@samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/arch/arm/mach-ssdtv/timex.h
+ * Later changes Copyright (C) 2010 SamyGO team
+ *
+ */
+
+#ifndef __ASM_ARCH_SSDTV_TIMEX_H
+#define __ASM_ARCH_SSDTV_TIMEX_H
+
+#include <asm/arch/platform.h>
+
+#define CLOCK_TICK_RATE		((PCLK >> 2) / (SYS_TIMER_PRESCALER + 1))
+
+#ifndef CONFIG_HIGH_RES_TIMERS
+extern unsigned long ssdtv_timer_read(void);
+#define mach_read_cycles()	ssdtv_timer_read()
+#else
+extern u64 ssdtv_clksrc_read(void);
+#define mach_read_cycles()	ssdtv_clksrc_read()
+#endif
+
+
+#endif /* __ASM_ARCH_SSDTV_TIMEX_H */
diff -urNP old/include/asm-arm/arch-ssdtv/uncompress.h new/include/asm-arm/arch-ssdtv/uncompress.h
--- old/include/asm-arm/arch-ssdtv/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/uncompress.h	2010-07-18 12:09:24.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/uncompress.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/uncompress.h
+ *
+ */
+
+static inline void putc(int c) {}
+static inline void flush(void) {}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
diff -urNP old/include/asm-arm/arch-ssdtv/vmalloc.h new/include/asm-arm/arch-ssdtv/vmalloc.h
--- old/include/asm-arm/arch-ssdtv/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ new/include/asm-arm/arch-ssdtv/vmalloc.h	2010-07-18 12:09:21.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/vmalloc.h
+ *
+ *  Copyright (C) 2006 Samsung Electronics co.
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * SamyGO: http://samygo.sourceforge.net/
+ * This file is copied from sources released by Samsung with GPLv2 license.
+ * Origin: http://opensource.samsung.com ->
+ * LA46B650.zip -> linux.cip.open.tgz -> linux/ssdtv_platform/include/asm-arm/arch-ssdtv/vmalloc.h
+ *
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+
+#define VMALLOC_OFFSET		(8 * 1024 * 1024)
+#define VMALLOC_START		(((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET - 1))
+#define VMALLOC_VMADDR(x)	((unsigned long)(x))
+#define VMALLOC_END		(PAGE_OFFSET + 0x20000000)
diff -urNP old/include/asm-arm/memory.h new/include/asm-arm/memory.h
--- old/include/asm-arm/memory.h	2007-02-24 00:52:30.000000000 +0100
+++ new/include/asm-arm/memory.h	2010-07-17 13:21:19.000000000 +0200
@@ -231,7 +231,7 @@
  */
 #include <linux/numa.h>
 #define arch_pfn_to_nid(pfn)	PFN_TO_NID(pfn)
-#define arch_local_page_offset(pfn, nid) LOCAL_MAP_NR((pfn) << PAGE_SHIFT)
+#define arch_local_page_offset(pfn, nid) LOCAL_MAP_PFN_NR((pfn) << PAGE_SHIFT)
 
 #define pfn_valid(pfn)						\
 	({							\
@@ -246,7 +246,7 @@
 	})
 
 #define virt_to_page(kaddr)					\
-	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_KVADDR_NR(kaddr))
 
 #define virt_addr_valid(kaddr)	(KVADDR_TO_NID(kaddr) < MAX_NUMNODES)
 
diff -urNP old/include/linux/serial_core.h new/include/linux/serial_core.h
--- old/include/linux/serial_core.h	2007-02-24 00:52:30.000000000 +0100
+++ new/include/linux/serial_core.h	2010-07-18 10:50:27.000000000 +0200
@@ -132,6 +132,8 @@
 
 #define PORT_S3C2412	73
 
+#define PORT_SSDTV	74
+
 
 #ifdef __KERNEL__
 
diff -urNP old/kernel/irq/manage.c new/kernel/irq/manage.c
--- old/kernel/irq/manage.c	2010-07-17 13:16:09.000000000 +0200
+++ new/kernel/irq/manage.c	2010-07-17 13:21:19.000000000 +0200
@@ -120,8 +120,10 @@
 	spin_lock_irqsave(&desc->lock, flags);
 	switch (desc->depth) {
 	case 0:
+#ifndef CONFIG_MACH_SSDTV
 		printk(KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);
 		WARN_ON(1);
+#endif
 		break;
 	case 1: {
 		unsigned int status = desc->status & ~IRQ_DISABLED;
