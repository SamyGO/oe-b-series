<?xml version="1.0"?>
<!--
  ex:ts=4:sw=4:sts=4:et
  -*- tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
    <bookinfo>
        <title>BitBake User Manual</title>
        <authorgroup>
            <corpauthor>BitBake Team</corpauthor>
        </authorgroup>
        <copyright>
            <year>2004, 2005, 2006</year>
            <holder>Chris Larson</holder>
            <holder>Phil Blundell</holder>
        </copyright>
        <legalnotice>
            <para>This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit <ulink url="http://creativecommons.org/licenses/by/2.5/">http://creativecommons.org/licenses/by/2.5/</ulink> or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.</para>
        </legalnotice>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <section>
            <title>Overview</title>
            <para>BitBake is, at its simplest, a tool for executing
tasks and managing metadata.  As such, its similarities to GNU make and other
build tools are readily apparent.  It was inspired by Portage, the package management system used by the Gentoo Linux distribution.  BitBake is the basis of the <ulink url="http://www.openembedded.org/">OpenEmbedded</ulink> project, which is being used to build and maintain a number of embedded Linux distributions, including OpenZaurus and Familiar.</para>
        </section>
        <section>
            <title>Background and Goals</title>
            <para>Prior to BitBake, no other build tool adequately met
the needs of an aspiring embedded Linux distribution.  All of the
buildsystems used by traditional desktop Linux distributions lacked
important functionality, and none of the ad-hoc
<emphasis>buildroot</emphasis> systems, prevalent in the
embedded space, were scalable or maintainable.</para>

      <para>Some important goals for BitBake were:
            <itemizedlist>
                <listitem><para>Handle crosscompilation.</para></listitem>
                <listitem><para>Handle interpackage dependencies (build time on target architecture, build time on native architecture, and runtime).</para></listitem>
                <listitem><para>Support running any number of tasks within a given package, including, but not limited to, fetching upstream sources, unpacking them, patching them, configuring them, et cetera.</para></listitem>
                <listitem><para>Must be linux distribution agnostic (both build and target).</para></listitem>
                <listitem><para>Must be architecture agnostic</para></listitem>
                <listitem><para>Must support multiple build and target operating systems (including cygwin, the BSDs, etc).</para></listitem>
                <listitem><para>Must be able to be self contained, rather than tightly integrated into the build machine's root filesystem.</para></listitem>
                <listitem><para>There must be a way to handle conditional metadata (on target architecture, operating system, distribution, machine).</para></listitem>
                <listitem><para>It must be easy for the person using the tools to supply their own local metadata and packages to operate against.</para></listitem>
                <listitem><para>Must make it easy to collaborate
between multiple projects using BitBake for their
builds.</para></listitem>
		<listitem><para>Should provide an inheritance mechanism to
share common metadata between many packages.</para></listitem>
                <listitem><para>Et cetera...</para></listitem>
            </itemizedlist>
        </para>
        <para>BitBake satisfies all these and many more.  Flexibility and power have always been the priorities.  It is highly extensible, supporting embedded Python code and execution of any arbitrary tasks.</para>
        </section>
    </chapter>
    <chapter>
        <title>Metadata</title>
        <section>
            <title>Description</title>
            <itemizedlist>
                <para>BitBake metadata can be classified into 3 major areas:</para>
                <listitem>
                    <para>Configuration Files</para>
                </listitem>
                <listitem>
                    <para>.bb Files</para>
                </listitem>
                <listitem>
                    <para>Classes</para>
                </listitem>
            </itemizedlist>
            <para>What follows are a large number of examples of BitBake metadata.  Any syntax which isn't supported in any of the aforementioned areas will be documented as such.</para>
            <section>
                <title>Basic variable setting</title>
                <para><screen><varname>VARIABLE</varname> = "value"</screen></para>
                <para>In this example, <varname>VARIABLE</varname> is <literal>value</literal>.</para>
            </section>
            <section>
                <title>Variable expansion</title>
                <para>BitBake supports variables referencing one another's contents using a syntax which is similar to shell scripting</para>
                <para><screen><varname>A</varname> = "aval"
<varname>B</varname> = "pre${A}post"</screen></para>
                <para>This results in <varname>A</varname> containing <literal>aval</literal> and <varname>B</varname> containing <literal>preavalpost</literal>.</para>
            </section>
            <section>
                <title>Setting a default value (?=)</title>
                <para><screen><varname>A</varname> ?= "aval"</screen></para>
                <para>If <varname>A</varname> is set before the above is called, it will retain it's previous value. If <varname>A</varname> is unset prior to the above call, <varname>A</varname> will be set to <literal>aval</literal>.  Note that this assignment is immediate, so if there are multiple ?= assignments to a single variable, the first of those will be used.</para>
            </section>
            <section>
                <title>Setting a default value (??=)</title>
                <para><screen><varname>A</varname> ??= "somevalue"</screen></para>
                <para><screen><varname>A</varname> ??= "someothervalue"</screen></para>
                <para>If <varname>A</varname> is set before the above, it will retain that value.  If <varname>A</varname> is unset prior to the above, <varname>A</varname> will be set to <literal>someothervalue</literal>.  This is a lazy version of ??=, in that the assignment does not occur until the end of the parsing process, so that the last, rather than the first, ??= assignment to a given variable will be used.</para>
            </section>
            <section>
                <title>Immediate variable expansion (:=)</title>
                <para>:= results in a variable's contents being expanded immediately, rather than when the variable is actually used.</para>
                <para><screen><varname>T</varname> = "123"
<varname>A</varname> := "${B} ${A} test ${T}"
<varname>T</varname> = "456"
<varname>B</varname> = "${T} bval"

<varname>C</varname> = "cval"
<varname>C</varname> := "${C}append"</screen></para>
                <para>In that example, <varname>A</varname> would contain <literal> test 123</literal>, <varname>B</varname> would contain <literal>456 bval</literal>, and <varname>C</varname> would be <literal>cvalappend</literal>.</para>
            </section>
            <section>
                <title>Appending (+=) and prepending (=+)</title>
                <para><screen><varname>B</varname> = "bval"
<varname>B</varname> += "additionaldata"
<varname>C</varname> = "cval"
<varname>C</varname> =+ "test"</screen></para>
                <para>In this example, <varname>B</varname> is now <literal>bval additionaldata</literal> and <varname>C</varname> is <literal>test cval</literal>.</para>
            </section>
            <section>
                <title>Appending (.=) and prepending (=.) without spaces</title>
                    <para><screen><varname>B</varname> = "bval"
<varname>B</varname> .= "additionaldata"
<varname>C</varname> = "cval"
<varname>C</varname> =. "test"</screen></para>
                <para>In this example, <varname>B</varname> is now <literal>bvaladditionaldata</literal> and <varname>C</varname> is <literal>testcval</literal>. In contrast to the above Appending and Prepending operators no additional space
will be introduced.</para>
            </section>
            <section>
                <title>Conditional metadata set</title>
                <para>OVERRIDES is a <quote>:</quote> separated variable containing each item you want to satisfy conditions.  So, if you have a variable which is conditional on <quote>arm</quote>, and <quote>arm</quote> is in OVERRIDES, then the <quote>arm</quote> specific version of the variable is used rather than the non-conditional version.  Example:</para>
                <para><screen><varname>OVERRIDES</varname> = "architecture:os:machine"
<varname>TEST</varname> = "defaultvalue"
<varname>TEST_os</varname> = "osspecificvalue"
<varname>TEST_condnotinoverrides</varname> = "othercondvalue"</screen></para>
                <para>In this example, <varname>TEST</varname> would be <literal>osspecificvalue</literal>, due to the condition <quote>os</quote> being in <varname>OVERRIDES</varname>.</para>
            </section>
            <section>
                <title>Conditional appending</title>
                <para>BitBake also supports appending and prepending to variables based on whether something is in OVERRIDES.  Example:</para>
                <para><screen><varname>DEPENDS</varname> = "glibc ncurses"
<varname>OVERRIDES</varname> = "machine:local"
<varname>DEPENDS_append_machine</varname> = " libmad"</screen></para>
                <para>In this example, <varname>DEPENDS</varname> is set to <literal>glibc ncurses libmad</literal>.</para>
            </section>
            <section>
                <title>Inclusion</title>
                <para>Next, there is the <literal>include</literal> directive, which causes BitBake to parse in whatever file you specify, and insert it at that location, which is not unlike <command>make</command>.  However, if the path specified on the <literal>include</literal> line is a relative path, BitBake will locate the first one it can find within <envar>BBPATH</envar>.</para>
            </section>
            <section>
                <title>Requiring Inclusion</title>
                <para>In contrast to the <literal>include</literal> directive, <literal>require</literal> will
raise an ParseError if the to be included file can not be found. Otherwise it will behave just like the <literal>
include</literal> directive.</para>
            </section>
            <section>
                <title>Python variable expansion</title>
                <para><screen><varname>DATE</varname> = "${@time.strftime('%Y%m%d',time.gmtime())}"</screen></para>
                <para>This would result in the <varname>DATE</varname> variable containing today's date.</para>
            </section>
            <section>
                <title>Defining executable metadata</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para><screen>do_mytask () {
    echo "Hello, world!"
}</screen></para>
                <para>This is essentially identical to setting a variable, except that this variable happens to be executable shell code.</para>
                <para><screen>python do_printdate () {
    import time
    print time.strftime('%Y%m%d', time.gmtime())
}</screen></para>
                <para>This is the similar to the previous, but flags it as python so that BitBake knows it is python code.</para>
            </section>
            <section>
                <title>Defining python functions into the global python namespace</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para><screen>def get_depends(bb, d):
    if bb.data.getVar('SOMECONDITION', d, True):
        return "dependencywithcond"
    else:
        return "dependency"

<varname>SOMECONDITION</varname> = "1"
<varname>DEPENDS</varname> = "${@get_depends(bb, d)}"</screen></para>
                <para>This would result in <varname>DEPENDS</varname> containing <literal>dependencywithcond</literal>.</para>
            </section>
            <section>
                <title>Variable Flags</title>
                <para>Variables can have associated flags which provide a way of tagging extra information onto a variable. Several flags are used internally by bitbake but they can be used externally too if needed. The standard operations mentioned above also work on flags.</para>
                <para><screen><varname>VARIABLE</varname>[<varname>SOMEFLAG</varname>] = "value"</screen></para>
                <para>In this example, <varname>VARIABLE</varname> has a flag, <varname>SOMEFLAG</varname> which is set to <literal>value</literal>.</para>
            </section>
            <section>
                <title>Inheritance</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>The <literal>inherit</literal> directive is a means of specifying what classes of functionality your .bb requires.  It is a rudimentary form of inheritance.  For example, you can easily abstract out the tasks involved in building a package that uses autoconf and automake, and put that into a bbclass for your packages to make use of.  A given bbclass is located by searching for classes/filename.oeclass in <envar>BBPATH</envar>, where filename is what you inherited.</para>
            </section>
            <section>
                <title>Tasks</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>In BitBake, each step that needs to be run for a given .bb is known as a task.  There is a command <literal>addtask</literal> to add new tasks (must be a defined python executable metadata and must start with <quote>do_</quote>) and describe intertask dependencies.</para>
                <para><screen>python do_printdate () {
    import time
    print time.strftime('%Y%m%d', time.gmtime())
}

addtask printdate before do_build</screen></para>
                <para>This defines the necessary python function and adds it as a task which is now a dependency of do_build (the default task).  If anyone executes the do_build task, that will result in do_printdate being run first.</para>
            </section>
            <section>
                <title>Events</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>BitBake allows to install event handlers.  Events are triggered at certain points during operation, such as, the beginning of operation against a given .bb, the start of a given task, task failure, task success, et cetera.  The intent was to make it easy to do things like email notifications on build failure.</para>
                <para><screen>addhandler myclass_eventhandler
python myclass_eventhandler() {
    from bb.event import NotHandled, getName
    from bb import data

    print "The name of the Event is %s" % getName(e)
    print "The file we run for is %s" % data.getVar('FILE', e.data, True)

    return NotHandled
}
</screen></para><para>
This event handler gets called every time an event is triggered. A global variable <varname>e</varname> is defined. <varname>e</varname>.data contains an instance of bb.data. With the getName(<varname>e</varname>)
method one can get the name of the triggered event.</para><para>The above event handler prints the name
of the event and the content of the <varname>FILE</varname> variable.</para>
            </section>
            <section>
                <title>Variants</title>
                <para>Two Bitbake features exist to facilitate the creation of multiple buildable incarnations from a single recipe file.</para>
                <para>The first is <varname>BBCLASSEXTEND</varname>.  This variable is a space separated list of classes to utilize to "extend" the recipe for each variant.  As an example, setting <screen>BBCLASSEXTEND = "native"</screen> results in a second incarnation of the current recipe being available.  This second incarantion will have the "native" class inherited.</para>
                <para>The second feature is <varname>BBVERSIONS</varname>.  This variable allows a single recipe to be able to build multiple versions of a project from a single recipe file, and allows you to specify conditional metadata (using the <varname>OVERRIDES</varname> mechanism) for a single version, or an optionally named range of versions:</para>
                <para><screen>BBVERSIONS = "1.0 2.0 git"
SRC_URI_git = "git://someurl/somepath.git"</screen></para>
                <para><screen>BBVERSIONS = "1.0.[0-6]:1.0.0+ \
              1.0.[7-9]:1.0.7+"
SRC_URI_append_1.0.7+ = "file://some_patch_which_the_new_versions_need.patch;patch=1"</screen></para>
                <para>Note that the name of the range will default to the original version of the recipe, so given OE, a recipe file of foo_1.0.0+.bb will default the name of its versions to 1.0.0+.  This is useful, as the range name is not only placed into overrides, it's also made available for the metadata to use in the form of the <varname>BPV</varname> variable, for use in file:// search paths (<varname>FILESPATH</varname>).</para>
            </section>
        </section>
        <section>
            <title>Dependency Handling</title>
            <para>Bitbake 1.7.x onwards works with the metadata at the task level since this is optimal when dealing with multiple threads of execution. A robust method of specifing task dependencies is therefore needed. </para>
            <section>
                <title>Dependencies internal to the .bb file</title>
                <para>Where the dependencies are internal to a given .bb file, the dependencies are handled by the previously detailed addtask directive.</para>
            </section>

            <section>
                <title>DEPENDS</title>
                <para>DEPENDS is taken to specify build time dependencies. The 'deptask' flag for tasks is used to signify the task of each DEPENDS which must have completed before that task can be executed.</para>
                <para><screen>do_configure[deptask] = "do_populate_staging"</screen></para>
                <para>means the do_populate_staging task of each item in DEPENDS must have completed before do_configure can execute.</para>
            </section>
            <section>
                <title>RDEPENDS</title>
                <para>RDEPENDS is taken to specify runtime dependencies. The 'rdeptask' flag for tasks is used to signify the task of each RDEPENDS which must have completed before that task can be executed.</para>
                <para><screen>do_package_write[rdeptask] = "do_package"</screen></para>
                <para>means the do_package task of each item in RDEPENDS must have completed before do_package_write can execute.</para>
            </section>
            <section>
                <title>Recursive DEPENDS</title>
                <para>These are specified with the 'recdeptask' flag and is used signify the task(s) of each DEPENDS which must have completed before that task can be executed. It applies recursively so also, the DEPENDS of each item in the original DEPENDS must be met and so on.</para>
            </section>
            <section>
                <title>Recursive RDEPENDS</title>
                <para>These are specified with the 'recrdeptask' flag and is used signify the task(s) of each RDEPENDS which must have completed before that task can be executed. It applies recursively so also, the RDEPENDS of each item in the original RDEPENDS must be met and so on. It also runs all DEPENDS first too.</para>
            </section>
            <section>
                <title>Inter Task</title>
                <para>The 'depends' flag for tasks is a more generic form of which allows an interdependency on specific tasks rather than specifying the data in DEPENDS or RDEPENDS.</para>
                <para><screen>do_patch[depends] = "quilt-native:do_populate_staging"</screen></para>
                <para>means the do_populate_staging task of the target quilt-native must have completed before the do_patch can execute.</para>
            </section>
        </section>

        <section>
            <title>Parsing</title>
            <section>
                <title>Configuration Files</title>
                <para>The first of the classifications of metadata in BitBake is configuration metadata.  This metadata is global, and therefore affects <emphasis>all</emphasis> packages and tasks which are executed.</para>
                <para>Bitbake will first search the current working directory for an optional "conf/bblayers.conf" configuration file. This file is expected to contain a BBLAYERS variable which is a space delimited list of 'layer' directories. For each directory in this list a "conf/layer.conf" file will be searched for and parsed with the LAYERDIR variable being set to the directory where the layer was found. The idea is these files will setup BBPATH and other variables correctly for a given build directory automatically for the user.</para>
                <para>Bitbake will then expect to find 'conf/bitbake.conf' somewhere in the user specified <envar>BBPATH</envar>.  That configuration file generally has include directives to pull in any other metadata (generally files specific to architecture, machine, <emphasis>local</emphasis> and so on.</para>
                <para>Only variable definitions and include directives are allowed in .conf files.</para>
            </section>
            <section>
                <title>Classes</title>
                <para>BitBake classes are our rudimentary inheritance mechanism.  As briefly mentioned in the metadata introduction, they're parsed when an <literal>inherit</literal> directive is encountered, and they are located in classes/ relative to the dirs in <envar>BBPATH</envar>.</para>
            </section>
            <section>
                <title>.bb Files</title>
                <para>A BitBake (.bb) file is a logical unit of tasks to be executed.  Normally this is a package to be built.  Inter-.bb dependencies are obeyed.  The files themselves are located via the <varname>BBFILES</varname> variable, which is set to a space separated list of .bb files, and does handle wildcards.</para>
            </section>
        </section>
    </chapter>

    <chapter>
        <title>File Download support</title>
        <section>
            <title>Overview</title>
            <para>BitBake provides support to download files this procedure is called fetching. The SRC_URI is normally used to indicate BitBake which files to fetch. The next sections will describe th available fetchers and the options they have. Each Fetcher honors a set of Variables and
a per URI parameters separated by a <quote>;</quote> consisting of a key and a value. The semantic of the Variables and Parameters are defined by the Fetcher. BitBakes tries to have a consistent semantic between the different Fetchers.
            </para>
        </section>

        <section>
            <title>Local File Fetcher</title>
            <para>The URN for the Local File Fetcher is <emphasis>file</emphasis>. The filename can be either absolute or relative. If the filename is relative <varname>FILESPATH</varname> and <varname>FILESDIR</varname> will be used to find the appropriate relative file depending on the <varname>OVERRIDES</varname>. Single files and complete directories can be specified.
<screen><varname>SRC_URI</varname>= "file://relativefile.patch"
<varname>SRC_URI</varname>= "file://relativefile.patch;this=ignored"
<varname>SRC_URI</varname>= "file:///Users/ich/very_important_software"
</screen>
            </para>
        </section>

        <section>
            <title>CVS File Fetcher</title>
            <para>The URN for the CVS Fetcher is <emphasis>cvs</emphasis>. This Fetcher honors the variables <varname>DL_DIR</varname>, <varname>SRCDATE</varname>, <varname>FETCHCOMMAND_cvs</varname>, <varname>UPDATECOMMAND_cvs</varname>. <varname>DL_DIRS</varname> specifies where a temporary checkout is saved, <varname>SRCDATE</varname> specifies which date to use when doing the fetching (the special value of "now" will cause the checkout to be updated on every build), <varname>FETCHCOMMAND</varname> and <varname>UPDATECOMMAND</varname> specify which executables should be used when doing the CVS checkout or update.
            </para>
            <para>The supported Parameters are <varname>module</varname>, <varname>tag</varname>, <varname>date</varname>, <varname>method</varname>, <varname>localdir</varname>, <varname>rsh</varname>. The <varname>module</varname> specifies which module to check out, the <varname>tag</varname> describes which CVS TAG should be used for the checkout by default the TAG is empty. A <varname>date</varname> can be specified to override the SRCDATE of the configuration to checkout a specific date.  The special value of "now" will cause the checkout to be updated on every build.<varname>method</varname> is by default <emphasis>pserver</emphasis>, if <emphasis>ext</emphasis> is used the <varname>rsh</varname> parameter will be evaluated and <varname>CVS_RSH</varname> will be set. Finally <varname>localdir</varname> is used to checkout into a special directory relative to <varname>CVSDIR></varname>.
<screen><varname>SRC_URI</varname> = "cvs://CVSROOT;module=mymodule;tag=some-version;method=ext"
<varname>SRC_URI</varname> = "cvs://CVSROOT;module=mymodule;date=20060126;localdir=usethat"
</screen>
            </para>
        </section>

        <section>
            <title>HTTP/FTP Fetcher</title>
            <para>The URNs for the HTTP/FTP are <emphasis>http</emphasis>, <emphasis>https</emphasis> and <emphasis>ftp</emphasis>. This Fetcher honors the variables <varname>DL_DIR</varname>, <varname>FETCHCOMMAND_wget</varname>, <varname>PREMIRRORS</varname>, <varname>MIRRORS</varname>. The <varname>DL_DIR</varname> defines where to store the fetched file, <varname>FETCHCOMMAND</varname> contains the command used for fetching. <quote>${URI}</quote> and <quote>${FILES}</quote> will be replaced by the uri and basename of the to be fetched file. <varname>PREMIRRORS</varname>
will be tried first when fetching a file if that fails the actual file will be tried and finally all <varname>MIRRORS</varname> will be tried.
            </para>
            <para>The only supported Parameter is <varname>md5sum</varname>. After a fetch the <varname>md5sum</varname> of the file will be calculated and the two sums will be compared.
            </para>
            <para><screen><varname>SRC_URI</varname> = "http://oe.handhelds.org/not_there.aac;md5sum=12343"
<varname>SRC_URI</varname> = "ftp://oe.handhelds.org/not_there_as_well.aac;md5sum=1234"
<varname>SRC_URI</varname> = "ftp://you@oe.handheld.sorg/home/you/secret.plan;md5sum=1234"
</screen></para>
        </section>

        <section>
            <title>SVK Fetcher</title>
            <para>
            <emphasis>Currently NOT supported</emphasis>
            </para>
        </section>

        <section>
            <title>SVN Fetcher</title>
            <para>The URN for the SVN Fetcher is <emphasis>svn</emphasis>.
            </para>
            <para>This Fetcher honors the variables <varname>FETCHCOMMAND_svn</varname>, <varname>DL_DIR</varname>, <varname>SRCDATE</varname>. <varname>FETCHCOMMAND</varname> contains the subversion command, <varname>DL_DIR</varname> is the directory where tarballs will be saved, <varname>SRCDATE</varname> specifies which date to use when doing the fetching (the special value of "now" will cause the checkout to be updated on every build).
            </para>
            <para>The supported Parameters are <varname>proto</varname>, <varname>rev</varname>. <varname>proto</varname> is the subversion prototype, <varname>rev</varname> is the subversions revision.
            </para>
            <para><screen><varname>SRC_URI</varname> = "svn://svn.oe.handhelds.org/svn;module=vip;proto=http;rev=667"
<varname>SRC_URI</varname> = "svn://svn.oe.handhelds.org/svn/;module=opie;proto=svn+ssh;date=20060126"
</screen></para>
        </section>

        <section>
            <title>GIT Fetcher</title>
            <para>The URN for the GIT Fetcher is <emphasis>git</emphasis>.
            </para>
            <para>The Variables <varname>DL_DIR</varname>, <varname>GITDIR</varname> are used. <varname>DL_DIR</varname> will be used to store the checkedout version. <varname>GITDIR</varname> will be used as the base directory where the git tree is cloned to.
            </para>
            <para>The Parameters are <emphasis>tag</emphasis>, <emphasis>protocol</emphasis>. <emphasis>tag</emphasis> is a git tag, the default is <quote>master</quote>. <emphasis>protocol</emphasis> is the git protocol to use and defaults to <quote>rsync</quote>.
            </para>
            <para><screen><varname>SRC_URI</varname> = "git://git.oe.handhelds.org/git/vip.git;tag=version-1"
<varname>SRC_URI</varname> = "git://git.oe.handhelds.org/git/vip.git;protocol=http"
            </screen></para>
        </section>

    </chapter>


    <chapter>
        <title>The bitbake command</title>
            <section>
                <title>Introduction</title>
                <para>bitbake is the primary command in the system.  It facilitates executing tasks in a single .bb file, or executing a given task on a set of multiple .bb files, accounting for interdependencies amongst them.</para>
            </section>
            <section>
                <title>Usage and Syntax</title>
                <para>
                    <screen><prompt>$ </prompt>bitbake --help
usage: bitbake [options] [package ...]

Executes the specified task (default is 'build') for a given set of BitBake files.
It expects that BBFILES is defined, which is a space separated list of files to
be executed.  BBFILES does support wildcards.
Default BBFILES are the .bb files in the current directory.

options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -b BUILDFILE, --buildfile=BUILDFILE
                        execute the task against this .bb file, rather than a
                        package from BBFILES.
  -k, --continue        continue as much as possible after an error. While the
                        target that failed, and those that depend on it,
                        cannot be remade, the other dependencies of these
                        targets can be processed all the same.
  -f, --force           force run of specified cmd, regardless of stamp status
  -i, --interactive     drop into the interactive mode also called the BitBake
                        shell.
  -c CMD, --cmd=CMD     Specify task to execute. Note that this only executes
                        the specified task for the providee and the packages
                        it depends on, i.e. 'compile' does not implicitly call
                        stage for the dependencies (IOW: use only if you know
                        what you are doing). Depending on the base.bbclass a
                        listtasks task is defined and will show available
                        tasks
  -r FILE, --read=FILE  read the specified file before bitbake.conf
  -v, --verbose         output more chit-chat to the terminal
  -D, --debug           Increase the debug level. You can specify this more
                        than once.
  -n, --dry-run         don't execute, just go through the motions
  -p, --parse-only      quit after parsing the BB files (developers only)
  -d, --disable-psyco   disable using the psyco just-in-time compiler (not
                        recommended)
  -s, --show-versions   show current and preferred versions of all packages
  -e, --environment     show the global or per-package environment (this is
                        what used to be bbread)
  -g, --graphviz        emit the dependency trees of the specified packages in
                        the dot syntax
  -I IGNORED_DOT_DEPS, --ignore-deps=IGNORED_DOT_DEPS
                        Stop processing at the given list of dependencies when
                        generating dependency graphs. This can help to make
                        the graph more appealing
  -l DEBUG_DOMAINS, --log-domains=DEBUG_DOMAINS
                        Show debug logging for the specified logging domains
  -P, --profile         profile the command and print a report


</screen>
                </para>
                <para>
                <example>
                    <title>Executing a task against a single .bb</title>
                    <para>Executing tasks for a single file is relatively simple.  You specify the file in question, and bitbake parses it and executes the specified task (or <quote>build</quote> by default).  It obeys intertask dependencies when doing so.</para>
                    <para><quote>clean</quote> task:</para>
                    <para><screen><prompt>$ </prompt>bitbake -b blah_1.0.bb -c clean</screen></para>
                    <para><quote>build</quote> task:</para>
                    <para><screen><prompt>$ </prompt>bitbake -b blah_1.0.bb</screen></para>
                </example>
                </para>
                <para>
                <example>
                    <title>Executing tasks against a set of .bb files</title>
                    <para>There are a number of additional complexities introduced when one wants to manage multiple .bb files.  Clearly there needs to be a way to tell bitbake what files are available, and of those, which we want to execute at this time.  There also needs to be a way for each .bb to express its dependencies, both for build time and runtime.  There must be a way for the user to express their preferences when multiple .bb's provide the same functionality, or when there are multiple versions of a .bb.</para>
                    <para>The next section, Metadata, outlines how one goes about specifying such things.</para>
                    <para>Note that the bitbake command, when not using --buildfile, accepts a <varname>PROVIDER</varname>, not a filename or anything else.  By default, a .bb generally PROVIDES its packagename, packagename-version, and packagename-version-revision.</para>
                    <screen><prompt>$ </prompt>bitbake blah</screen>
                    <screen><prompt>$ </prompt>bitbake blah-1.0</screen>
                    <screen><prompt>$ </prompt>bitbake blah-1.0-r0</screen>
                    <screen><prompt>$ </prompt>bitbake -c clean blah</screen>
                    <screen><prompt>$ </prompt>bitbake virtual/whatever</screen>
                    <screen><prompt>$ </prompt>bitbake -c clean virtual/whatever</screen>
                </example>
                <example>
                    <title>Generating dependency graphs</title>
                    <para>BitBake is able to generate dependency graphs using the dot syntax. These graphs can be converted
to images using the <application>dot</application> application from <ulink url="http://www.graphviz.org">graphviz</ulink>. 
Two files will be written into the current working directory, <emphasis>depends.dot</emphasis> containing dependency information at the package level and <emphasis>task-depends.dot</emphasis> containing a breakdown of the dependencies at the task level. To stop depending on common depends one can use the <prompt>-I depend</prompt> to omit these from the graph. This can lead to more readable graphs. E.g. this way <varname>DEPENDS</varname> from inherited classes, e.g. base.bbclass, can be removed from the graph.</para>
                    <screen><prompt>$ </prompt>bitbake -g blah</screen>
                    <screen><prompt>$ </prompt>bitbake -g -I virtual/whatever -I bloom blah</screen>
                </example>
                </para>
            </section>
            <section>
                <title>Special variables</title>
                <para>Certain variables affect bitbake operation:</para>
                <section>
                    <title><varname>BB_NUMBER_THREADS</varname></title>
                    <para> The number of threads bitbake should run at once (default: 1).</para>
                </section>
            </section>
            <section>
                <title>Metadata</title>
                <para>As you may have seen in the usage information, or in the information about .bb files, the BBFILES variable is how the bitbake tool locates its files.  This variable is a space separated list of files that are available, and supports wildcards.
                <example>
                    <title>Setting BBFILES</title>
                    <programlisting><varname>BBFILES</varname> = "/path/to/bbfiles/*.bb"</programlisting>
                </example></para>
                <para>With regard to dependencies, it expects the .bb to define a <varname>DEPENDS</varname> variable, which contains a space separated list of <quote>package names</quote>, which themselves are the <varname>PN</varname> variable.  The <varname>PN</varname> variable is, in general, by default, set to a component of the .bb filename.</para>
                <example>
                    <title>Depending on another .bb</title>
                    <para>a.bb:
    <screen>PN = "package-a"
DEPENDS += "package-b"</screen>
                    </para>
                    <para>b.bb:
    <screen>PN = "package-b"</screen>
                    </para>
                </example>
                <example>
                    <title>Using PROVIDES</title>
                    <para>This example shows the usage of the PROVIDES variable, which allows a given .bb to specify what functionality it provides.</para>
                    <para>package1.bb:
    <screen>PROVIDES += "virtual/package"</screen>
                    </para>
                    <para>package2.bb:
    <screen>DEPENDS += "virtual/package"</screen>
                    </para>
                    <para>package3.bb:
    <screen>PROVIDES += "virtual/package"</screen>
                    </para>
                    <para>As you can see, here there are two different .bb's that provide the same functionality (virtual/package).  Clearly, there needs to be a way for the person running bitbake to control which of those providers gets used.  There is, indeed, such a way.</para>
                    <para>The following would go into a .conf file, to select package1:
    <screen>PREFERRED_PROVIDER_virtual/package = "package1"</screen>
                    </para>
                </example>
                <example>
                    <title>Specifying version preference</title>
                    <para>When there are multiple <quote>versions</quote> of a given package, bitbake defaults to selecting the most recent version, unless otherwise specified.  If the .bb in question has a <varname>DEFAULT_PREFERENCE</varname> set lower than the other .bb's (default is 0), then it will not be selected.  This allows the person or persons maintaining the repository of .bb files to specify their preferences for the default selected version.  In addition, the user can specify their preferences with regard to version.</para>
                    <para>If the first .bb is named <filename>a_1.1.bb</filename>, then the <varname>PN</varname> variable will be set to <quote>a</quote>, and the <varname>PV</varname> variable will be set to 1.1.</para>
                    <para>If we then have an <filename>a_1.2.bb</filename>, bitbake will choose 1.2 by default.  However, if we define the following variable in a .conf that bitbake parses, we can change that.
    <screen>PREFERRED_VERSION_a = "1.1"</screen>
                    </para>
                </example>
                <example>
                    <title>Using <quote>bbfile collections</quote></title>
                    <para>bbfile collections exist to allow the user to have multiple repositories of bbfiles that contain the same exact package.  For example, one could easily use them to make one's own local copy of an upstream repository, but with custom modifications that one does not want upstream.  Usage:</para>
                    <screen>BBFILES = "/stuff/openembedded/*/*.bb /stuff/openembedded.modified/*/*.bb"
BBFILE_COLLECTIONS = "upstream local"
BBFILE_PATTERN_upstream = "^/stuff/openembedded/"
BBFILE_PATTERN_local = "^/stuff/openembedded.modified/"
BBFILE_PRIORITY_upstream = "5"
BBFILE_PRIORITY_local = "10"</screen>
                </example>
            </section>
    </chapter>
</book>
